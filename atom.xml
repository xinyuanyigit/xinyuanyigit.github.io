<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WANG&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-09-01T10:54:13.482Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>WANG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/09/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2024/09/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2024-09-01T10:14:47.933Z</published>
    <updated>2024-09-01T10:54:13.482Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-消息队列"><a href="#title-消息队列" class="headerlink" title="title:消息队列"></a>title:消息队列</h2><h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><p>可以把消息队列看作是一个<strong>存放消息</strong>的容器，当需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列 <strong>Queue</strong> 是一种<strong>先进先出的数据结构</strong>，所以消费消息时也是<strong>按照顺序来消费</strong>的。</p><img src="../images/image-20240901181749820.png" alt="image-20240901181749820" style="zoom:80%;" /><p>参与消息传递的双方称为 <strong>生产者</strong> 和 <strong>消费者</strong> ，生产者负责发送消息，消费者负责处理消息。</p><p><img src="/../images/image-20240901181822833.png" alt="image-20240901181822833"></p><h2 id="消息队列有什么用？"><a href="#消息队列有什么用？" class="headerlink" title="消息队列有什么用？"></a>消息队列有什么用？</h2><p>通常来说，使用消息队列主要能为我们的系统带来下面三点好处：</p><ol><li>异步处理</li><li>削峰&#x2F;限流</li><li>降低系统耦合</li></ol><p>除了这三点之外，消息队列还有其他的一些应用场景，例如实现分布式事务、顺序保证和数据流处理。</p><h3 id="异步处理："><a href="#异步处理：" class="headerlink" title="异步处理："></a>异步处理：</h3><p><img src="/../images/image-20240901182255481.png" alt="image-20240901182255481"></p><p>将用户请求中耗时的操作，通过消息队列实现异步处理，将对应的消息发送到消息队列之后就立即返回结果，减少响应的时间，提高用户的体验。随后，再对消息进行消费。</p><p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功。比如手机订火车票和电影票。</p><h3 id="削峰-限流："><a href="#削峰-限流：" class="headerlink" title="削峰&#x2F;限流："></a>削峰&#x2F;限流：</h3><p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</strong></p><p>比如。在一些秒杀、促销活动场景中，合理使用消息队列可以有效抵御短时间内的大量请求打到后端系统，避免了大量请求对系统的冲击。如下图所示：</p><img src="../images/image-20240901183319976.png" alt="image-20240901183319976" style="zoom:67%;" /><h3 id="降低系统耦合："><a href="#降低系统耦合：" class="headerlink" title="降低系统耦合："></a>降低系统耦合：</h3><p>使用消息队列还可以降低系统耦合性。如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性就会更好一些。</p><p>生产者（客户端）发送消息到消息队列中去，消费者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p><p><img src="/../images/image-20240901183538290.png" alt="image-20240901183538290"></p><p><strong>消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong></p><p>例如，我们商城系统分为用户、订单、财务、仓储、消息通知、物流、风控等多个服务。用户在完成下单后，需要调用财务（扣款）、仓储（库存管理）、物流（发货）、消息通知（通知用户发货）、风控（风险评估）等服务。使用消息队列后，下单操作和后续的扣款、发货、通知等操作就解耦了，下单完成发送一个消息到消息队列，需要用到的地方去订阅这个消息进行消费即可。</p><p><img src="/../images/image-20240901183755059.png" alt="image-20240901183755059"></p><p>另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p><p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了另外 5 种消息模型。</p><h3 id="实现分布式事务："><a href="#实现分布式事务：" class="headerlink" title="实现分布式事务："></a>实现分布式事务：</h3><h3 id="保证消息顺序处理："><a href="#保证消息顺序处理：" class="headerlink" title="保证消息顺序处理："></a>保证消息顺序处理：</h3><p>在很多应用场景中，处理数据的顺序至关重要。消息队列保证数据按照特定的顺序被处理，适用于那些对数据顺序有严格要求的场景。大部分消息队列，例如 RocketMQ、RabbitMQ、Pulsar、Kafka，都支持顺序消息。</p><h3 id="延时-定时处理："><a href="#延时-定时处理：" class="headerlink" title="延时&#x2F;定时处理："></a>延时&#x2F;定时处理：</h3><p>消息发送后不会立即被消费，而是指定一个时间，到时间后再消费。大部分消息队列，例如 RocketMQ、RabbitMQ、Pulsar、Kafka，都支持定时&#x2F;延时消息。</p><h3 id="数据流处理："><a href="#数据流处理：" class="headerlink" title="数据流处理："></a>数据流处理：</h3><p>针对分布式系统产生的海量数据流，如业务日志、监控数据、用户行为等，消息队列可以实时或批量收集这些数据，并将其导入到大数据处理引擎中，实现高效的数据流管理和处理。</p><h2 id="使用消息队列可能带来什么问题？"><a href="#使用消息队列可能带来什么问题？" class="headerlink" title="使用消息队列可能带来什么问题？"></a>使用消息队列可能带来什么问题？</h2><p><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了。</p><p><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题。</p><p><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了。</p><h2 id="RPC和消息队列的区别？"><a href="#RPC和消息队列的区别？" class="headerlink" title="RPC和消息队列的区别？"></a>RPC和消息队列的区别？</h2><p>RPC 和消息队列都是分布式微服务系统中重要的组件之一</p><ul><li><p><strong>从用途来看</strong>：RPC 主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。消息队列主要用来降低系统耦合性、实现任务异步、有效地进行流量削峰。</p></li><li><p><strong>从通信方式来看</strong>：RPC 是双向直接网络通讯，消息队列是单向引入中间载体的网络通讯。</p></li><li><p><strong>从架构上来看</strong>：消息队列需要把消息存储起来，RPC 则没有这个要求，因为前面也说了 RPC 是双向直接网络通讯。</p></li><li><p><strong>从请求处理的时效性来看</strong>：通过 RPC 发出的调用一般会立即被处理，存放在消息队列中的消息并不一定会立即被处理。</p></li></ul><p>RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-消息队列&quot;&gt;&lt;a href=&quot;#title-消息队列&quot; class=&quot;headerlink&quot; title=&quot;title:消息队列&quot;&gt;&lt;/a&gt;title:消息队列&lt;/h2&gt;&lt;h2 id=&quot;什么是消息队列？&quot;&gt;&lt;a href=&quot;#什么是消息队列？</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>项目问题</title>
    <link href="http://example.com/2024/08/29/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2024/08/29/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</id>
    <published>2024-08-29T11:23:54.067Z</published>
    <updated>2024-08-29T11:55:49.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扫码登录的设计与实现"><a href="#扫码登录的设计与实现" class="headerlink" title="扫码登录的设计与实现"></a>扫码登录的设计与实现</h2><h3 id="用户名密码登录："><a href="#用户名密码登录：" class="headerlink" title="用户名密码登录："></a>用户名密码登录：</h3><p>在登录页面输入用户名和密码，服务端验证用户名和密码，验证失败返回登录页重新登录，验证成功生成token，存储token到redis中，返回token给前端。之后每次请求都会携带该token，验证该token，验证通过，执行后续接口，返回执行结果。验证失败，返回登录页重新登录。</p><h3 id="二维码扫码登录："><a href="#二维码扫码登录：" class="headerlink" title="二维码扫码登录："></a>二维码扫码登录：</h3><p>二维码是PC端、手机端和服务端之间的桥梁。</p><p>流程：</p><ol><li>登录页发送请求到服务端，服务端会生成一个唯一ID，并把这个唯一ID设置到redis中，设置它的过期时间。服务端返回这个唯一ID到PC端，PC端会根据这个唯一ID生成一个二维码。在这个步骤里，在redis中存储的是一个以唯一ID为键的值，它有三种状态，如果这个以唯一ID为键的值为null，表示为未扫码，有值的话表示为扫描成功，如果不存在这个key，表示为已失效。</li><li>手机端扫描二维码，解析出唯一ID，然后把appId、手机端token以及解析出的唯一ID传递到服务端，服务端首先会验证手机端的token是否有效，如果无效则验证失败，有效的话会验证唯一ID，判断是否存在唯一ID，如果不存在，表示二维码已经失效了，如果存在且状态为未扫码，则生成一个PC端的token存储在redis中的这个唯一ID为键的值，其他情况都是验证失败。</li><li>PC端会以轮询的方式发送异步请求向服务端查询这个唯一ID的状态，如果redis中的唯一ID为键的值为null，表示位扫码，如果这个唯一ID不存在，表示二维码已失效，如果找到这个唯一ID对应的值，表示扫码成功，同时返回这个PC端的token，提示登录成功。</li></ol><h2 id="简要描述一下如何使用-CompletableFuture-来并行加载数据？"><a href="#简要描述一下如何使用-CompletableFuture-来并行加载数据？" class="headerlink" title="简要描述一下如何使用 CompletableFuture 来并行加载数据？"></a>简要描述一下如何使用 <code>CompletableFuture</code> 来并行加载数据？</h2><p>在项目中，我们需要在网站主页上展示课程分类和热门课程等数据。为了提高页面加载速度，我们使用了<code>CompletableFuture</code>来并行加载这些数据。具体来说，我首先创建了两个<code>CompletableFuture</code>实例，分别用于加载课程分类和热门课程数据。然后使用<code>CompletableFuture.allOf()</code>方法将这两个任务并行执行，并在所有任务完成后执行回调方法来处理结果。</p><h2 id="你有没有考虑过线程池的配置？为什么？"><a href="#你有没有考虑过线程池的配置？为什么？" class="headerlink" title="你有没有考虑过线程池的配置？为什么？"></a>你有没有考虑过线程池的配置？为什么？</h2><p>我考虑过线程池的配置。默认情况下，<code>CompletableFuture</code> 使用 <code>ForkJoinPool.commonPool()</code> 作为线程池，但是在我们的项目中，由于预计会有大量的并发请求，我创建了一个专用的线程池，并通过 <code>runAsync()</code> 方法显式地指定了这个线程池。这样做可以更好地控制并发级别和资源使用，确保系统的稳定性和响应性。</p><h2 id="订单场景下的分布式锁？"><a href="#订单场景下的分布式锁？" class="headerlink" title="订单场景下的分布式锁？"></a>订单场景下的分布式锁？</h2><p>redisson实现的分布式锁。</p><h2 id="本地缓存、redis缓存与数据库Mysql进行数据同步。"><a href="#本地缓存、redis缓存与数据库Mysql进行数据同步。" class="headerlink" title="本地缓存、redis缓存与数据库Mysql进行数据同步。"></a>本地缓存、redis缓存与数据库Mysql进行数据同步。</h2><ol><li>DB 修改数据：现在数据库中进行数据修改</li><li>通过监听 canal 消息，触发缓存的更新：使用canal监听数据库的变更操作，当检测到数据变化时，触发缓存更新。</li><li>针对 redis 缓存中，因为集群中只共享一份，直接同步缓存即可</li><li>针对本地缓存，因为集群中存在多分，且分散在不同的 JVM 实例中。故再借助广播 MQ 机制，通知到各个业务实例。同步本地缓存</li></ol><h2 id="MySQL主备复制原理"><a href="#MySQL主备复制原理" class="headerlink" title="MySQL主备复制原理"></a>MySQL主备复制原理</h2><p>Mysql的master主库将数据变更写入binlog日志文件中</p><p>slave从库向master主库发起dump请求，从库将主库的binglog日志拷贝到自己的relaylog中继日志中，</p><p>从库重放relaylog中继日志中的数据，将数据同步到自己的数据库中。</p><h2 id="canal-工作原理"><a href="#canal-工作原理" class="headerlink" title="canal 工作原理"></a>canal 工作原理</h2><p>canal模拟Mysql中的主备复制，将自己伪装成Mysql的从库，向主库发送dump请求，Mysql的主库收到dump请求后，推送binglog日志给从库也就是canal，canal解析binlog数据。</p><h2 id="使用redis怎么统计网站的UV？"><a href="#使用redis怎么统计网站的UV？" class="headerlink" title="使用redis怎么统计网站的UV？"></a>使用redis怎么统计网站的UV？</h2><p><strong>UV：指一定时间内，访问网站的不同用户的数量。</strong></p><h3 id="方法一：使用incr命令。"><a href="#方法一：使用incr命令。" class="headerlink" title="方法一：使用incr命令。"></a>方法一：使用incr命令。</h3><p>incr命令是一个简单的key-value格式的计数器，用户每次访问网站，都会根据用户的唯一标识去执行incr命令，最后通过get命令来获取访问数量。但这个方法不能去重，也就是说，同一个用户访问网站两次，incr命令就会使访问量加2，不适用于UV。</p><h3 id="方法二：使用set数据类型来设计。"><a href="#方法二：使用set数据类型来设计。" class="headerlink" title="方法二：使用set数据类型来设计。"></a>方法二：使用set数据类型来设计。</h3><p>set集合拥有唯一性，可以用于统计去重。通过sadd命令来进行统计访问量。通过scard命令来获取访问量。但这个方法也有一个问题，那就是需要大量内存。</p><h3 id="方法三：使用BitMaps类型来设计。"><a href="#方法三：使用BitMaps类型来设计。" class="headerlink" title="方法三：使用BitMaps类型来设计。"></a>方法三：使用BitMaps类型来设计。</h3><p>BitMaps是redis中的特殊的数据类型。它用一个bit来表示某个值的状态，只存储0或1，所以它可以节省极大的内存。我们可以通过setbit命令来进行统计访问量，通过bitcount来获取访问量。但如果统计的对象很多的话，还是需要很多内存。</p><h3 id="方法四：使用HyperLogLog类型来设计。"><a href="#方法四：使用HyperLogLog类型来设计。" class="headerlink" title="方法四：使用HyperLogLog类型来设计。"></a>方法四：使用HyperLogLog类型来设计。</h3><p>HyperLogLog是redis中的特殊的数据类型，它使用极小的内存就可以统计大量的元素。HyperLogLog是通过pfadd命令来添加元素进行统计，使用pfcount命令类进行获取统计量。</p><h2 id="redis是怎么做一个排行榜的？"><a href="#redis是怎么做一个排行榜的？" class="headerlink" title="redis是怎么做一个排行榜的？"></a>redis是怎么做一个排行榜的？</h2><h3 id="Mysql的order-by关键字："><a href="#Mysql的order-by关键字：" class="headerlink" title="Mysql的order by关键字："></a><strong>Mysql的order by关键字：</strong></h3><p>order by关键字可以根据指定字段进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column1,column2...</span><br><span class="line"><span class="keyword">from</span> tablename</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> column1,column2... <span class="keyword">desc</span><span class="operator">/</span><span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><p>这种方式好处是比较简单，不需要引入额外的组件，成本低。坏处是每次生成排行榜都比较耗时，对数据库的性能消耗比较大，数据量一大，业务场景一复杂就不可以了。</p><p>创建一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> cus_order(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    score <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="keyword">primary</span> key (id)</span><br><span class="line">)engine <span class="operator">=</span>innodb auto_increment<span class="operator">=</span><span class="number">100000</span> <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>定义一个存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_cus_order(<span class="keyword">in</span> start_num <span class="type">int</span>,<span class="keyword">in</span> max_num <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> start_num;</span><br><span class="line">    while i<span class="operator">&lt;</span>max_num do</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> cus_order(id,score,name) <span class="keyword">values</span>(i,rand() <span class="operator">*</span> <span class="number">1000000</span>,concat(<span class="string">&#x27;user&#x27;</span>,i));</span><br><span class="line">        <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> insert_cus_order(<span class="number">1</span>,<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure><p>对这100w数据根据score进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> score,name <span class="keyword">from</span> cus_order <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>为了查看sql的执行时间，通过<code>show profiles</code>命令查看。</p><p>通过<code>show variables</code>命令查看<code>profiles</code>是否是开启状态。默认情况是关闭的，通过<code>set @@profiling = 1</code>命令开启。</p><p><strong>如何进行优化呢？</strong></p><p><strong>加索引并且限制排序数据量。</strong></p><p>对score字段加索引，并限制只查询前500的数据。</p><p>适用于数据量小且业务不复杂的场景。</p><h3 id="redis的sorted-set"><a href="#redis的sorted-set" class="headerlink" title="redis的sorted set"></a>redis的sorted set</h3><p>通过<code>sorted set</code>能够轻松应对百万级用户数据排序。</p><p><code>sorted set</code>类似于<code>set</code>集合，但和set相比，<code>sorted set</code>增加了一个权重参数<code>score</code>，使得集合中的元素可以按照score进行有序排列，还可以通过<code>score</code>的范围获取元素列表。</p><p><strong>常用命令：</strong></p><p><img src="/../images/image-20240829193946274.png" alt="image-20240829193946274"></p><p><strong>使用：</strong></p><p>把数据添加到<code>sort set</code>中</p><p><img src="/../images/image-20240829194018733.png" alt="image-20240829194018733"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd cus_order_set 112.0 user1 100.0 user2 123.0 user3  147.0 user4 33.0 user5 55 user6</span><br></pre></td></tr></table></figure><p>查询所有用户的排行榜：<code>zrevrange</code>从大到小，<code>zrange</code>从小到大</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrange cus_order_set 0 -1 withscores</span><br></pre></td></tr></table></figure><p>只查询包含前3的排行榜：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrange cus_order_set 0 2 withscores</span><br></pre></td></tr></table></figure><p>查询某个用户的具体排名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrank cus_order_set &#x27;user1&#x27;</span><br></pre></td></tr></table></figure><p>查询某个用户的分数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscore cus_order_set &#x27;user1&#x27;</span><br></pre></td></tr></table></figure><p>redis中只保存了排行榜所展示的数据，需要用户的具体数据的话还是要到mysql中查询。</p><p><strong>复杂排行操作：</strong></p><p>比如实现指定日期(最近3天)的数据排序：</p><p>添加数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zadd 20240823 112 user1 100 user2 123 user3</span><br><span class="line">zadd 20240824 147 user4 33 user5 55 user6</span><br><span class="line">zadd 20240825 112 user1 100 user2 123 user5</span><br></pre></td></tr></table></figure><p>求并集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 求并集</span><br><span class="line">zunionstore last_3_day 3 20240823 20240824 20240825 weights 1 1 1</span><br></pre></td></tr></table></figure><p>查看结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrange last_3_day 0 -1 withscores</span><br></pre></td></tr></table></figure><p><strong>如果不想对score进行求和，可以通过指定<code>aggregate</code>参数 来设置聚合函数：</strong></p><ul><li>sum：对于不同集合的相同元素使用求和作为结果集中对应元素的score。不设置<code>aggregate</code>值，默认是<code>sum</code></li><li>max：对于不同集合的相同元素使用最大值作为结果集中对应元素的score。</li><li>min：对于不同集合的相同元素使用最小值作为结果集中对应元素的score。</li></ul><p><strong>排行榜的课程包括课程标题、作者、课程图片和浏览量：</strong></p><ul><li>在Redis中，您可以将每个文章的信息作为一个键值对存储，键可以是文章ID，值是一个JSON字符串，包含了文章标题、作者、文字图片和浏览量等信息。</li><li>对于排行榜，您可以使用Redis的Sorted Set数据结构，其中成员是文章ID，分值是根据浏览量或其他指标计算得出的排名依据。</li><li>当文章信息发生变化时（比如浏览量增加），更新Redis中的相应键值对，并调整Sorted Set中的分值。</li><li>要显示排行榜，首先从Redis的Sorted Set中获取前N个得分最高的文章ID。</li><li>然后，根据这些文章ID从Redis中获取对应的文章信息（包括标题、作者、文字图片和浏览量等）。</li><li>最后，将这些信息组合成排行榜列表并返回给前端展示。</li></ul><h2 id="怎么统计的浏览量？"><a href="#怎么统计的浏览量？" class="headerlink" title="怎么统计的浏览量？"></a>怎么统计的浏览量？</h2><h2 id="聚合应用平台是什么？"><a href="#聚合应用平台是什么？" class="headerlink" title="聚合应用平台是什么？"></a>聚合应用平台是什么？</h2><p>聚合应用指将两种以上的数据源加在一起，形成一个整合应用。包括人力资源管理系统中的员工信息，招聘信息，绩效信息等，还包括客户关系管理系统中的客户信息、客户反馈信息等，还包括公司的学习平台的课程信息等等，还对接了百度的搜索。</p><ol><li>节约了去不同搜索网站搜索资料的时间，快速切换不同网站的搜索结果，方便快速找到想要的内容；</li><li>资源丰富，好的聚合搜索网站往往能够提供丰富的资源站点，能够帮助你找到想要的结果；</li></ol><h2 id="描述一下基于AI的答题应用共享平台这个项目"><a href="#描述一下基于AI的答题应用共享平台这个项目" class="headerlink" title="描述一下基于AI的答题应用共享平台这个项目"></a>描述一下基于AI的答题应用共享平台这个项目</h2><p>这是一个基于 Spring Boot 的 AI智能答题平台。前台用户可以创建应用并基于 AI 快速生成应用题目，设置自己的评分规则。支持检索、分享应用和在线答题，并基于AI或多种评分算法得到应用的答案。后台管理员可以审核应用、集中管理整站内容，并进行统计分析。整个系统后端可以分为：用户模块、应用模块、题目模块、评分模块、回答模块、AI模块、统计与分析模块。</p><p>用户模块：提供用户的注册、登录、查询等功能。</p><p>应用模块：提供应用的增删改查、分享等功能。</p><p>题目模块：提供题目的增删改查，包括AI生成题目等功能。</p><p>评分模块：提供应用的评分规则定制，以及进行AI评分的功能。</p><p>统计与分析模块：提供热门应用排行分析，应用浏览量统计等等功能。</p><p><img src="C:\Users\15461\AppData\Roaming\Typora\typora-user-images\image-20240823202603111.png" alt="image-20240823202603111"></p><h2 id="为什么使用策略模式来封装不同的评分算法？有什么好处？怎么实现？"><a href="#为什么使用策略模式来封装不同的评分算法？有什么好处？怎么实现？" class="headerlink" title="为什么使用策略模式来封装不同的评分算法？有什么好处？怎么实现？"></a>为什么使用策略模式来封装不同的评分算法？有什么好处？怎么实现？</h2><p>策略模式：定义一系列算法，将每个算法封装起来，使这些算法可以相互替换。策略模式可以使算法独立于客户端而变化。</p><p>策略模式的原理：</p><p>定义一些独立的类封装不同算法，这里的每一种类中的算法就是一种策略，为了保证这些策略具有一致性，提供一个抽象的策略类来做算法的声明。</p><p><img src="/../images/image-20240829194112658.png" alt="image-20240829194112658"></p><p><strong>策略模式的优点：</strong></p><p>策略类之间可以自由切换：由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p><p>易于扩展：增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“。</p><p><strong>策略模式使用场景：</strong></p><p>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</p><blockquote><p>策略模式最大的作用在于分离使用算法的逻辑和算法自身实现的逻辑，这样就意味着当我们想要优化算法自身的实现逻辑时就变得非常便捷，一方面可以采用最新的算法实现逻辑，另一方面可以直接弃用旧算法而采用新算法。使用策略模式能够很方便地进行替换。</p></blockquote><p>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</p><blockquote><p>在实际开发中，有许多算法可以实现某一功能，如查找、排序等，通过 if-else 等条件判断语句来进行选择非常方便。但是这就会带来一个问题：当在这个算法类中封装了大量查找算法时，该类的代码就会变得非常复杂，维护也会突然就变得非常困难。虽然策略模式看上去比较笨重，但实际上在每一次新增策略时都通过新增类来进行隔离，短期虽然不如直接写 if-else 来得效率高，但长期来看，维护单一的简单类耗费的时间其实远远低于维护一个超大的复杂类。</p></blockquote><p>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</p><blockquote><p>如果我们不希望客户知道复杂的、与算法相关的数据结构,在具体策略类中封装算法与相关数据结构,可以提高算法的保密性与安全性。</p></blockquote><h2 id="如何实现测评类应用的评分算法？"><a href="#如何实现测评类应用的评分算法？" class="headerlink" title="如何实现测评类应用的评分算法？"></a>如何实现测评类应用的评分算法？</h2><ol><li>测评类每道题目的答案都设置了属性，如A对应M，B对应T，C对应B，D对应I。</li><li>根据用户选择的答案计算出对应属性的数量，例如 M有10个，B有10个，T有5个，I有1个，设置一个Map，key为属性值，value为对应的数量。</li><li>评分结果表的结果也设置了对应的属性，对于每种评分结果，遍历属性集合，从上述的Map中找到对应的属性的统计的数量，求和。</li><li>遍历所有的评分结果，使用上述算法，得到最大的值，此时的评分结果就是用户的评分结果。</li></ol><img src="../images/image-20240824145753413.png" alt="image-20240824145753413" style="zoom: 80%;" /><h2 id="怎么实现AI生成题目的功能？"><a href="#怎么实现AI生成题目的功能？" class="headerlink" title="怎么实现AI生成题目的功能？"></a>怎么实现AI生成题目的功能？</h2><ol><li>编写Prompt告诉AI模型需要什么样的内容，可以使用自然语言进行格式的描述。</li><li>进行系统预设、少样本学习、任务拆解等技巧优化Prompt，使AI能更好的理解和生成题目。系统预设是指预先设定一些规则或模板；少样本学习是指利用少量已有的题目训练AI模型；任务拆解则是指将复杂的任务分解为多个简单的子任务，逐个解决。</li><li>通过AI平台提供的界面，测试和调整Prompt，直到得到满意的结果。</li><li>为了提高响应速度，使用流式化和SSE技术进行优化。</li><li>流式API允许实时接收AI生成的内容，不用等待整个内容生成完毕再一次返回。</li><li>通过Server-Sent Events (SSE) 技术，让服务器向客户端实时推送数据。用SSE将生成的单道题目实时推送给前端，提高用户体验。</li></ol><h2 id="如何流式调用AI并实时获取AI返回的内容？"><a href="#如何流式调用AI并实时获取AI返回的内容？" class="headerlink" title="如何流式调用AI并实时获取AI返回的内容？"></a>如何流式调用AI并实时获取AI返回的内容？</h2><p>智谱AI的SDK提供了流式调用的能力，我自主封装了一个AI Manager简化了流式调用的传参，返回一个响应式对象。利用响应式编程框架RXJava来处理AI实时返回的数据，将AI返回的字符串拼接成一个一个题目，通过SSE实时推送给前端。</p><h2 id="如何实现一个一个流式生成题目？"><a href="#如何实现一个一个流式生成题目？" class="headerlink" title="如何实现一个一个流式生成题目？"></a>如何实现一个一个流式生成题目？</h2><p>利用RxJava链式调用并处理AI实时返回的异步数据。通过map，filter处理字符串，通过flatmap把字符串映射为单个字符，再通过<strong>括号平衡算法</strong>准确拼接出单道题目。</p><p><strong>括号平衡算法：</strong>题目是json格式的，左括号数一定等于右括号数。遍历当前字符串，用一个计数器来计数括号数，出现左括号+1，出现右括号-1，直到计数器为0时，表示一道题目，之后通过SSE技术推送题目给前端。</p><h2 id="什么是SSE技术？他有什么优点和不足？适用于哪些场景？"><a href="#什么是SSE技术？他有什么优点和不足？适用于哪些场景？" class="headerlink" title="什么是SSE技术？他有什么优点和不足？适用于哪些场景？"></a>什么是SSE技术？他有什么优点和不足？适用于哪些场景？</h2><p>SSE技术是一种用于从服务器到客户端的单向、实时数据传输技术，它是基于HTTP协议实现的。</p><p><strong>特点：</strong></p><ul><li>单向通信：SSE只支持服务器向客户端的单向通行，客户端不能向服务器发送数据。</li><li>文本格式：SSE使用纯文本格式传输数据，使用HTTP响应的<code>text/evebt-stream</code>MIME类型。</li><li>保持连接：SSE通过保持一个持久的HTTP连接，实现服务器向客户端推送更新。不需要客户端频繁轮询。</li><li>自动重连：如果连接中断，浏览器会自动重新连接，保证数据流的连续性。</li></ul><p><strong>优点：</strong></p><ul><li>简单易用</li><li>实时性</li><li>标准化</li><li>无需握手机制</li></ul><p><strong>不足：</strong></p><ul><li>单向通信：</li><li>连接维持：需要保持持续连接，可能造成服务器资源占用。</li></ul><p><strong>使用场景：</strong></p><ul><li>实时更新：股票价格，体育比赛比分、新闻更新等需要实时推送的应用。</li><li>日志监控：实时监控服务器日志或应用状态。</li><li>AI对话：常见的AI模型页面对话。</li></ul><h2 id="使用AI的过程中，有没有出现不稳定的情况？"><a href="#使用AI的过程中，有没有出现不稳定的情况？" class="headerlink" title="使用AI的过程中，有没有出现不稳定的情况？"></a>使用AI的过程中，有没有出现不稳定的情况？</h2><p><img src="C:\Users\15461\AppData\Roaming\Typora\typora-user-images\image-20240824155549480.png" alt="image-20240824155549480"></p><h2 id="在项目中如何利用缓存？怎么设计的？"><a href="#在项目中如何利用缓存？怎么设计的？" class="headerlink" title="在项目中如何利用缓存？怎么设计的？"></a>在项目中如何利用缓存？怎么设计的？</h2><p><strong>在AI评分中存在两个问题：</strong></p><ul><li>AI调用需要费用，如果用户对同样的应用做出同样的回答，理论会得到一样的回答，不需要每次都询问AI。存在资源浪费的问题。</li><li>AI评分的响应时间较长，效率有待提高。</li></ul><p>考虑到减少响应时间和数据复用，选择用缓存技术来优化AI评分功能。选择成本较低的本地缓存caffeine来实现。</p><p><strong>设计缓存key：</strong></p><p>用户对同样应用做出一样的回答会得到同样的结果，可以将应用id和用户的答案列表作为key，因为答案列表可能会很长，所以用hash算法来压缩答案列表，节省空间。</p><p><strong>value：</strong></p><p>缓存AI回答的结果。为了节省空间，存储二进制数据。</p><p><strong>缓存过期时间：</strong></p><p>必须设置过期时间，为了节省空间。设置过期时间为1天。</p><p><strong>业务流程：</strong></p><ol><li>在用户用AI回答前，先hash处理用户答案选择，得到摘要，拼接缓存key。</li><li>通过这个key查询缓存，若命中则直接返回命中结果</li><li>若未命中，则请求AI回答。</li><li>正确解析AI的返回结果，将其放到缓存里。</li></ol><h2 id="什么是幂等设计，怎么实现的？"><a href="#什么是幂等设计，怎么实现的？" class="headerlink" title="什么是幂等设计，怎么实现的？"></a>什么是幂等设计，怎么实现的？</h2><p>使用相同参数多次调用同一接口，产生的结果或影响和单词调用结果是一样的。</p><p>使用数据库唯一索引来保证幂等操作：</p><p><strong>流程：</strong></p><ol><li>用户进入答题页面，请求后端返回一个全局唯一id</li><li>用户提交回答时，不仅要提交答案列表，要包括全局唯一id</li><li>后端将这个全局唯一id保存到数据库中的某个唯一索引字段上，利用数据库的唯一索引实现幂等。</li></ol><p>为防止用户多次提交重复答案，基于<strong>雪花算法为每次答题分配唯一id</strong>，并通过数据库主键实现 幂等设计，避免了重复的脏数据。</p><p>核心是通过时间戳(亳秒)保证递增，通过机器id 、服务id 和递增序号(同一毫秒内递增)，保证唯一性。</p><h2 id="什么是线程池隔离-你在项目中为什么要使用线程池隔离，有什么好处"><a href="#什么是线程池隔离-你在项目中为什么要使用线程池隔离，有什么好处" class="headerlink" title="什么是线程池隔离?你在项目中为什么要使用线程池隔离，有什么好处?"></a>什么是线程池隔离?你在项目中为什么要使用线程池隔离，有什么好处?</h2><p>线程池隔离是一种通过为不同的任务类型或者不同的资源来分配不同的线程池。这种机制可以有效的控制不同任务之间的影响，<strong>提高系统的稳定性和可靠性</strong>。</p><p>如果所有的业务都使用同一个线程池，最大的问题就是不同任务之间相互影响。所以在一些敏感的场景中，需要隔离线程池，它的好处有：</p><ol><li>故障隔离，缩小事故范围</li><li>资源隔离，防止业务之间抢占资源。同时支持更精细化的管理资源，比如不重要的场景给小一点的线程池，核心场景配置大的线程池。</li><li>性能优化，一些任务的场景是CPU密集型，一些是I&#x2F;O密集型，不同任务类型需要配置不同的线程池。</li></ol><p>在本项目中，因为服务器资源有限，对于AI批量生成题目功能，用户分为会员和普通用户，会员会分配核心线程数更大的线程池，普通用户分配核心线程数更小的线程池。</p><h2 id="点赞服务系统架构设计："><a href="#点赞服务系统架构设计：" class="headerlink" title="点赞服务系统架构设计："></a>点赞服务系统架构设计：</h2><h2 id="如何进行预估订单？"><a href="#如何进行预估订单？" class="headerlink" title="如何进行预估订单？"></a>如何进行预估订单？</h2><h3 id="Drools规则引擎的工作原理"><a href="#Drools规则引擎的工作原理" class="headerlink" title="Drools规则引擎的工作原理"></a>Drools规则引擎的工作原理</h3><h2 id="乘客下单的接口："><a href="#乘客下单的接口：" class="headerlink" title="乘客下单的接口："></a>乘客下单的接口：</h2><h2 id="实现附近的搜索功能："><a href="#实现附近的搜索功能：" class="headerlink" title="实现附近的搜索功能："></a>实现附近的搜索功能：</h2><h2 id="超卖？"><a href="#超卖？" class="headerlink" title="超卖？"></a>超卖？</h2><p><img src="C:\Users\15461\AppData\Roaming\Typora\typora-user-images\image-20240815182115597.png" alt="image-20240815182115597"></p><p><img src="C:\Users\15461\AppData\Roaming\Typora\typora-user-images\image-20240815182242630.png" alt="image-20240815182242630"></p><p><img src="C:\Users\15461\AppData\Roaming\Typora\typora-user-images\image-20240815182314478.png" alt="image-20240815182314478"></p><p><img src="C:\Users\15461\AppData\Roaming\Typora\typora-user-images\image-20240815182338791.png" alt="image-20240815182338791"></p><p><img src="C:\Users\15461\AppData\Roaming\Typora\typora-user-images\image-20240816171224083.png" alt="image-20240816171224083"></p><p><img src="C:\Users\15461\AppData\Roaming\Typora\typora-user-images\image-20240817105344937.png" alt="image-20240817105344937"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;扫码登录的设计与实现&quot;&gt;&lt;a href=&quot;#扫码登录的设计与实现&quot; class=&quot;headerlink&quot; title=&quot;扫码登录的设计与实现&quot;&gt;&lt;/a&gt;扫码登录的设计与实现&lt;/h2&gt;&lt;h3 id=&quot;用户名密码登录：&quot;&gt;&lt;a href=&quot;#用户名密码登录：&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2024/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2024/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-08-29T11:23:54.065Z</published>
    <updated>2024-08-29T07:47:31.905Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式</title>
    <link href="http://example.com/2024/08/29/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://example.com/2024/08/29/%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2024-08-29T11:23:54.063Z</published>
    <updated>2024-08-29T11:39:07.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式锁解决了什么问题？"><a href="#分布式锁解决了什么问题？" class="headerlink" title="分布式锁解决了什么问题？"></a>分布式锁解决了什么问题？</h2><p>分布式锁是一种在分布式系统中用于协调多个节点间对共享资源访问的技术。它解决了以下几种问题：</p><ol><li><strong>资源竞争</strong>:<ul><li>在分布式系统中，多个节点可能需要同时访问同一份共享资源（如数据库、文件系统或其他服务）。如果没有适当的协调机制，这些节点可能会同时修改资源，导致数据不一致或丢失。</li></ul></li><li><strong>一致性问题</strong>:<ul><li>在分布式环境中，多个节点上的操作需要保持一致性。例如，当多个节点尝试同时更新同一个数据库记录时，需要确保只有一个节点成功更新，以避免数据冲突。</li></ul></li><li><strong>并发控制</strong>:<ul><li>分布式锁可以帮助控制并发操作，确保在特定时间段内只有一个节点能够访问或修改共享资源。这对于需要原子性的操作尤其重要，例如事务处理。</li></ul></li><li><strong>协调操作</strong>:<ul><li>分布式锁可以用于协调分布式系统中的多个节点执行某些操作的顺序。例如，在分布式计算任务中，可能需要按顺序执行任务以保证最终结果的正确性。</li></ul></li></ol><h2 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h2><p>在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。</p><p>举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况：</p><ul><li><p>线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。</p></li><li><p>线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</p></li><li><p>线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</p></li><li><p>线程 1 继续执行，将库存数量减少 1 个，然后返回成功。</p></li><li><p>线程 2 继续执行，将库存数量减少 1 个，然后返回成功。</p></li><li><p>此时就发生了超卖问题，导致商品被多卖了一份。</p></li></ul><p><img src="/../images/image-20240829193823988.png" alt="image-20240829193823988"></p><p>为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁总是假设此时是最坏的情况，认为访问共享资源总是会出现问题(比如数据被修改)，所以每次在获取共享资源的操作时，都会进行加锁，这样其他线程在访问该资源时，因为拿不到锁而进行阻塞等待，知道持有锁的线程释放该锁。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><h2 id="分布式锁的诞生："><a href="#分布式锁的诞生：" class="headerlink" title="分布式锁的诞生："></a>分布式锁的诞生：</h2><p>对于单机多线程来说，在 Java 中，通常使用 <code>ReentrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。<img src="/../images/image-20240829193846669.png" alt="image-20240829193846669"></p><p>从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。</p><p>分布式系统下，不同的服务&#x2F;客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong> 就诞生了。</p><p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。</p><p><img src="/../images/image-20240829193905421.png" alt="image-20240829193905421"></p><p>从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。</p><h2 id="分布式锁所具备的条件："><a href="#分布式锁所具备的条件：" class="headerlink" title="分布式锁所具备的条件："></a>分布式锁所具备的条件：</h2><p>一个最基本的分布式锁需要满足：</p><ul><li><strong>互斥</strong>：任意一个时刻，锁只能被一个线程持有。</li><li><strong>高可用</strong>：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。</li><li><strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取锁。</li></ul><p>除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：</p><ul><li><strong>高性能</strong>：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。</li><li><strong>非阻塞</strong>：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。</li></ul><h2 id="分布式锁的常见实现方式有哪些？"><a href="#分布式锁的常见实现方式有哪些？" class="headerlink" title="分布式锁的常见实现方式有哪些？"></a>分布式锁的常见实现方式有哪些？</h2><ul><li>基于关系型数据库比如 MySQL 实现分布式锁。</li><li>基于分布式协调服务 ZooKeeper 实现分布式锁。</li><li>基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。</li></ul><p>关系型数据库的方式一般是通过唯一索引或者排他锁实现。不过，一般不会使用这种方式，问题太多比如性能太差、不具备锁失效机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分布式锁解决了什么问题？&quot;&gt;&lt;a href=&quot;#分布式锁解决了什么问题？&quot; class=&quot;headerlink&quot; title=&quot;分布式锁解决了什么问题？&quot;&gt;&lt;/a&gt;分布式锁解决了什么问题？&lt;/h2&gt;&lt;p&gt;分布式锁是一种在分布式系统中用于协调多个节点间对共享资源访问</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://example.com/2024/08/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2024/08/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-08-29T11:23:54.062Z</published>
    <updated>2024-08-29T11:37:57.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Future类介绍"><a href="#Future类介绍" class="headerlink" title="Future类介绍"></a>Future类介绍</h2><p>Future是异步思想的典型应用，主要用在一些需要执行耗时操作任务的场景，避免线程一直在原地等待耗时任务，导致效率低效。具体流程如下：</p><p>当我们在执行某一个耗时任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以进行其他逻辑，不用等待耗时操作的执行完成。等到其他的逻辑执行完成后，可以通过Future类获耗时任务的执行结果。这样一来，执行效率就得到明显提高。核心思想就是异步调用。</p><h2 id="Future接口有5个方法："><a href="#Future接口有5个方法：" class="headerlink" title="Future接口有5个方法："></a>Future接口有5个方法：</h2><p><img src="/../images/image-20240829193057425.png" alt="image-20240829193057425"></p><h2 id="CompletionStage介绍"><a href="#CompletionStage介绍" class="headerlink" title="CompletionStage介绍"></a>CompletionStage介绍</h2><p><code>CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p><h2 id="CompletableFuture的介绍"><a href="#CompletableFuture的介绍" class="headerlink" title="CompletableFuture的介绍"></a>CompletableFuture的介绍</h2><p>CompletableFuture实现了Future接口和CompletionStage接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><h2 id="CompletableFuture的常见操作："><a href="#CompletableFuture的常见操作：" class="headerlink" title="CompletableFuture的常见操作："></a>CompletableFuture的常见操作：</h2><h3 id="创建CompletableFuture类："><a href="#创建CompletableFuture类：" class="headerlink" title="创建CompletableFuture类："></a>创建CompletableFuture类：</h3><ul><li>通过 new 关键字。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = new CompletableFuture&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>基于 <code>CompletableFuture</code> 自带的静态工厂方法：<code>runAsync()</code>、<code>supplyAsync()</code> 。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier);</span><br><span class="line">// 使用自定义线程池(推荐)</span><br><span class="line">static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor);</span><br><span class="line">static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable);</span><br><span class="line">// 使用自定义线程池(推荐)</span><br><span class="line">static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor);</span><br></pre></td></tr></table></figure><p><code>supplyAsync()</code> 方法接受的参数是 <code>Supplier&lt;U&gt;</code> ，这也是一个函数式接口，<code>U</code> 是返回结果值的类型。当你需要异步操作且关心返回结果的时候,可以使用 <code>supplyAsync()</code> 方法。</p><p><code>runAsync()</code> 方法接受的参数是 <code>Runnable</code> ，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用 <code>runAsync()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; System.out.println(&quot;hello!&quot;));</span><br><span class="line">future.get();// 输出 &quot;hello!&quot;</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &quot;hello!&quot;);</span><br><span class="line">assertEquals(&quot;hello!&quot;, future2.get());</span><br></pre></td></tr></table></figure><h3 id="处理异步结算的结果"><a href="#处理异步结算的结果" class="headerlink" title="处理异步结算的结果"></a>处理异步结算的结果</h3><p>当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：</p><ul><li><code>thenApply()</code></li></ul><p><code>thenApply()</code>方法允许指定一个函数来处理<code>CompletableFuture</code>的结果，并返回一个新的<code>CompletableFuture</code>。当连续调用<code>thenApply</code>方法时，这些操作实际是串联在一起，形成一个处理链。</p><p>如果<code>CompletableFuture</code>已经完成，那么第一次调用<code>thenApply()</code>会立即执行，并设置新的结果。后续的<code>thenApply()</code>调用将不会影响结果，因为<code>CompletableFuture</code>已经完成并且结果已经确定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testThenApplyOnCompletedFuture() throws Exception &#123;</span><br><span class="line">       // 创建一个已完成的 CompletableFuture</span><br><span class="line">       CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(&quot;hello!&quot;)</span><br><span class="line">               .thenApply(s -&gt; s + &quot; world&quot;);</span><br><span class="line"></span><br><span class="line">       // 再次尝试使用 thenApply，这次调用将被忽略</span><br><span class="line">       future = future.thenApply(s -&gt; s + &quot;!&quot;);</span><br><span class="line"></span><br><span class="line">       // 验证结果</span><br><span class="line">       assertEquals(&quot;hello! world&quot;, future.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果 <code>CompletableFuture</code> 尚未完成，那么连续调用 <code>thenApply</code> 会形成一个处理链。一旦 <code>CompletableFuture</code> 完成，整个处理链将按顺序执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSequentialThenApply() throws Exception &#123;</span><br><span class="line">        // 创建一个未完成的 CompletableFuture</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &quot;hello!&quot;);</span><br><span class="line"></span><br><span class="line">        // 连续调用 thenApply</span><br><span class="line">        future = future.thenApply(s -&gt; s + &quot; world&quot;)</span><br><span class="line">                       .thenApply(s -&gt; s + &quot;!&quot;);</span><br><span class="line"></span><br><span class="line">        // 验证结果</span><br><span class="line">        assertEquals(&quot;hello world!&quot;, future.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><code>thenAccept()</code></li></ul><p><code>thenAccept()</code> 方法接受一个 <code>Consumer&lt;T&gt;</code> 类型的参数，这个参数是一个函数式接口，它有一个方法 <code>accept(T t)</code>，用于消费 <code>CompletableFuture</code> 的结果，并且没有返回值。</p><p><strong>使用场景</strong></p><ul><li><strong>消费结果</strong>:<ul><li>当你只需要消费 <code>CompletableFuture</code> 的结果而不关心返回值时，可以使用 <code>thenAccept()</code>。</li></ul></li><li><strong>副作用操作</strong>:<ul><li>如果你想在 <code>CompletableFuture</code> 完成后执行一些副作用操作，如打印日志、更新数据库等，可以使用 <code>thenAccept()</code>。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testThenAccept() throws Exception &#123;</span><br><span class="line">        // 创建已完成的 CompletableFuture</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(&quot;hello!&quot;);</span><br><span class="line"></span><br><span class="line">        // 使用 thenAccept 打印结果</span><br><span class="line">        future.thenAccept(System.out::println);</span><br><span class="line"></span><br><span class="line">        // 验证结果</span><br><span class="line">        assertEquals(&quot;hello!&quot;, future.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><code>thenRun()</code></li></ul><p><code>thenRun()</code>方法用于在<code>CompletableFuture</code>完成后执行一个Runnable任务。<code>thenRun()</code> 不接受任何参数，也不返回任何值。</p><p><strong>使用场景</strong></p><ul><li><strong>副作用操作</strong>:<ul><li>如果你想在 <code>CompletableFuture</code> 完成后执行一些副作用操作，如打印日志、触发事件等，可以使用 <code>thenRun()</code>。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testThenRun() throws Exception &#123;</span><br><span class="line">        // 创建已完成的 CompletableFuture</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.completedFuture(null);</span><br><span class="line"></span><br><span class="line">        // 使用 thenRun 执行一个操作</span><br><span class="line">        future.thenRun(() -&gt; System.out.println(&quot;CompletableFuture is completed&quot;));</span><br><span class="line"></span><br><span class="line">        // 确保操作被执行</span><br><span class="line">        // 注意: 这里没有使用 assertEquals 因为 thenRun 不返回任何值</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><code>whenComplete()</code></li></ul><p><code>whenComplete()</code> 方法是 <code>CompletableFuture</code> 提供的一个方法，用于在 <code>CompletableFuture</code> 完成后执行一个操作，无论结果成功还是失败。</p><p><code>whenComplete()</code> 方法接受一个 <code>BiConsumer&lt;RESULT, Throwable&gt;</code> 类型的参数，这个参数是一个函数式接口，它有两个方法参数：一个是 <code>CompletableFuture</code> 的结果（如果成功），另一个是可能导致 <code>CompletableFuture</code> 失败的异常（如果失败）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testWhenComplete() throws Exception &#123;</span><br><span class="line">       // 创建一个未完成的 CompletableFuture</span><br><span class="line">       CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           if (Math.random() &gt; 0.5) &#123;</span><br><span class="line">               throw new RuntimeException(&quot;Simulated error&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           return &quot;Hello!&quot;;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       // 使用 whenComplete 记录结果或异常</span><br><span class="line">       future.whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">           if (throwable == null) &#123;</span><br><span class="line">               System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               System.err.println(&quot;Exception: &quot; + throwable.getMessage());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       // 等待 CompletableFuture 完成</span><br><span class="line">       try &#123;</span><br><span class="line">           System.out.println(&quot;Future result: &quot; + future.get());</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           System.err.println(&quot;Caught exception: &quot; + e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>handle()</code></p><p>通过 <code>handle()</code> 方法来处理任务执行过程中可能出现的抛出异常的情况。</p><p><code>handle()</code> 方法接受一个 <code>BiFunction&lt;RESULT, Throwable, COMPLETION&gt;</code> 类型的参数，这个参数是一个函数式接口，它有两个方法参数：一个是 <code>CompletableFuture</code> 的结果（如果成功），另一个是可能导致 <code>CompletableFuture</code> 失败的异常（如果失败）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testHandle() throws Exception &#123;</span><br><span class="line">       // 创建一个未完成的 CompletableFuture</span><br><span class="line">       CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           if (Math.random() &gt; 0.5) &#123;</span><br><span class="line">               throw new RuntimeException(&quot;Simulated error&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           return &quot;Hello!&quot;;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       // 使用 handle 处理结果或异常</span><br><span class="line">       CompletableFuture&lt;String&gt; handledFuture = future.handle((result, throwable) -&gt; &#123;</span><br><span class="line">           if (throwable == null) &#123;</span><br><span class="line">               return &quot;Processed: &quot; + result;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               System.err.println(&quot;Error: &quot; + throwable.getMessage());</span><br><span class="line">               return &quot;Default value&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       // 获取处理后的结果</span><br><span class="line">       String processedResult = handledFuture.get();</span><br><span class="line">       System.out.println(&quot;Processed result: &quot; + processedResult);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>exceptionally()</code> </p><ul><li><p><code>exceptionally()</code> 方法专门用于处理 <code>CompletableFuture</code> 完成时发生的异常。</p></li><li><p>它只在 <code>CompletableFuture</code> 完成时发生异常的情况下才会被调用。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    if (Math.random() &gt; 0.5) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Simulated error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;Hello!&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; handledFuture = future.exceptionally(throwable -&gt; &#123;</span><br><span class="line">    System.err.println(&quot;Error: &quot; + throwable.getMessage());</span><br><span class="line">    return &quot;Default value&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">String result = handledFuture.join();</span><br><span class="line">System.out.println(&quot;Result: &quot; + result);</span><br></pre></td></tr></table></figure><h3 id="组合CompletableFuture"><a href="#组合CompletableFuture" class="headerlink" title="组合CompletableFuture"></a>组合CompletableFuture</h3><p><code>thenCompose()</code></p><p><code>thenCompose()</code>按顺序连接多个CompletableFuture对象，实现异步的任务链。它的作用是将前一个任务的返回结果作为下一个任务的输入参数，从而形成一个依赖关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future</span><br><span class="line">        = CompletableFuture.supplyAsync(() -&gt; &quot;hello!&quot;)</span><br><span class="line">        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + &quot;world!&quot;));</span><br><span class="line">assertEquals(&quot;hello!world!&quot;, future.get());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>thenCombine()</code></strong> </p><ul><li><code>thenCombine()</code> 方法用于组合两个 <code>CompletableFuture</code> 的结果，这两个 <code>CompletableFuture</code> 必须都完成才能继续执行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &quot;World&quot;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; combinedFuture = future1.thenCombine(future2, (s1, s2) -&gt; s1 + &quot; &quot; + s2);</span><br><span class="line"></span><br><span class="line">String result = combinedFuture.join();</span><br><span class="line">System.out.println(&quot;Combined result: &quot; + result);</span><br></pre></td></tr></table></figure><p><strong><code>thenCompose()</code> 和 <code>thenCombine()</code> 有什么区别呢？</strong></p><ul><li><p><code>thenCompose()</code> 可以链接两个 <code>CompletableFuture</code> 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</p></li><li><p><code>thenCombine()</code> 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</p></li></ul><p><code>acceptEither()</code></p><p>任务组合操作<code>acceptEitherAsync()</code>会在异步任务 1 和异步任务 2 中的任意一个完成时触发执行任务 3，但是需要注意，这个触发时机是不确定的。如果任务 1 和任务 2 都还未完成，那么任务 3 就不能被执行。</p><h3 id="并行运行多个CompletableFuture"><a href="#并行运行多个CompletableFuture" class="headerlink" title="并行运行多个CompletableFuture"></a>并行运行多个CompletableFuture</h3><p><code>allof</code></p><ul><li><code>allof</code>这个静态方法可以并行运行多个 CompletableFuture，经常需要并行运行多个互不相关的任务，这些任务之间没有依赖关系，可以互相独立地运行。</li><li><strong><code>allOf()</code> 方法会等到所有的 <code>CompletableFuture</code> 都运行完成之后再返回</strong></li></ul><p><code>anyof</code></p><p><strong><code>anyOf()</code> 方法不会等待所有的 <code>CompletableFuture</code> 都运行完成之后再返回，只要有一个执行完成即可！</strong></p><p><code>join()</code>:<code>join()</code> 可以让程序等<code>future1</code> 和 <code>future2</code> 都运行完了之后再继续执行。</p><h2 id="CompletableFuture的使用建议："><a href="#CompletableFuture的使用建议：" class="headerlink" title="CompletableFuture的使用建议："></a>CompletableFuture的使用建议：</h2><h3 id="1-使用自定义线程池"><a href="#1-使用自定义线程池" class="headerlink" title="1.使用自定义线程池"></a>1.使用自定义线程池</h3><p><code>CompletableFuture</code> 默认使用<code>ForkJoinPool.commonPool()</code> 作为执行器，这个线程池是全局共享的，可能会被其他任务占用，导致性能下降或者饥饿。因此，建议使用自定义的线程池来执行 <code>CompletableFuture</code> 的异步任务，可以提高并发度和灵活性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ThreadPoolConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ThreadPoolExecutor threadPoolExecutor() &#123;</span><br><span class="line">        int processors = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">        // 设置最大线程数为处理器数量的两倍</span><br><span class="line">        int maxThreads = Math.min(processors * 2, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        // 设置空闲线程存活时间为 60 秒</span><br><span class="line">        long keepAliveTime = 60L;</span><br><span class="line"></span><br><span class="line">        // 设置队列大小为处理器数量的三倍</span><br><span class="line">        int queueCapacity = processors * 3;</span><br><span class="line"></span><br><span class="line">        // 创建线程池</span><br><span class="line">        return new ThreadPoolExecutor(</span><br><span class="line">                processors + 1, // 核心线程数</span><br><span class="line">                maxThreads,     // 最大线程数</span><br><span class="line">                keepAliveTime,  // 空闲线程存活时间</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;&gt;(queueCapacity), // 任务队列</span><br><span class="line">                Executors.defaultThreadFactory(),          </span><br><span class="line">                new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-尽量避免使用get-方法"><a href="#2-尽量避免使用get-方法" class="headerlink" title="2.尽量避免使用get()方法"></a>2.尽量避免使用get()方法</h3><p><code>CompletableFuture</code>的<code>get()</code>方法是阻塞的，尽量避免使用。如果必须要使用的话，需要添加超时时间，否则可能会导致主线程一直等待，无法执行其他任务。设置超时时间后，如果超时还未获得结果会抛出 <code>TimeoutException</code> 异常。</p><h3 id="3-正确进行异常处理"><a href="#3-正确进行异常处理" class="headerlink" title="3.正确进行异常处理"></a>3.正确进行异常处理</h3><p>使用 <code>CompletableFuture</code>的时候一定要以正确的方式进行异常处理，避免异常丢失或者出现不可控问题。</p><p>下面是一些建议：</p><ul><li>使用 <code>whenComplete</code> 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。</li><li>使用 <code>exceptionally</code> 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。</li><li>使用 <code>handle</code> 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。</li><li>使用 <code>CompletableFuture.allOf</code> 方法可以组合多个 <code>CompletableFuture</code>，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复。</li></ul><h3 id="4-合并组合多个异步任务"><a href="#4-合并组合多个异步任务" class="headerlink" title="4.合并组合多个异步任务"></a>4.合并组合多个异步任务</h3><p>正确使用 <code>thenCompose()</code> 、 <code>thenCombine()</code> 、<code>acceptEither()</code>、<code>allOf()</code>、<code>anyOf()</code>等方法来组合多个异步任务，以满足实际业务的需求，提高程序执行效率。</p><h2 id="什么是进程和线程？"><a href="#什么是进程和线程？" class="headerlink" title="什么是进程和线程？"></a>什么是进程和线程？</h2><h3 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h3><p>进程是程序一次执行的过程，是系统运行程序的基本单位，因此是动态的。系统运行一个程序即是一个进程从创建，运行到销毁的过程。</p><p>在Java中当我们启动一个main函数，实际上就是启动一个jvm进程，而main函数所在的线程就是这个进程中的一个线程，也被称为主线程。</p><h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>线程和进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行过程中可以产生多个线程。与进程不同的是，同一个进程中的线程会共享进程的<strong>堆和方法区</strong>里的资源，每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程中做切换工作时，负担要比进程小得多，也正是如此，线程被称为轻量级进程。</p><p><strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p><h3 id="进程与线程的区别，以及优缺点？"><a href="#进程与线程的区别，以及优缺点？" class="headerlink" title="进程与线程的区别，以及优缺点？"></a>进程与线程的区别，以及优缺点？</h3><img src="../images/image-20240829193121314.png" alt="image-20240829193121314" style="zoom:80%;" /><p>一个进程可以有多个线程，在同一个进程中的线程可以共享进程的堆和方法区资源(方法区在jdk1.8之后变成元空间)，但每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。</p><p><strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p><h3 id="程序计数器为什么是线程私有的？"><a href="#程序计数器为什么是线程私有的？" class="headerlink" title="程序计数器为什么是线程私有的？"></a>程序计数器为什么是线程私有的？</h3><p>程序计数器主要有两个作用：</p><p>1.字节码解释器通过改变程序计数器来进行一次读取指令，从而实现代码的流程控制，如顺序执行、选择、循环等操作。</p><p>2.在多线程环境下，程序计数器可以记录线程执行到了哪个位置，在进行线程切换时，可以找到线程上次执行到了哪个位置。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h3 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h3><p><strong>虚拟机栈：</strong>每个Java方法在执行前都会创建一个栈帧用来存储局部表量表、操作数栈、常量池等信息。从方法调用到执行完毕的过程中，就对应着一个栈帧在Java虚拟机栈中的入栈和出战的过程。</p><p><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</strong>。</p><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h3 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h2 id="如何创建线程？"><a href="#如何创建线程？" class="headerlink" title="如何创建线程？"></a>如何创建线程？</h2><p>Java中创建线程有很多种方式，比如实现Runnable、Callable接口、继承Thread类和根据线程池来创建，不过这些方法本质并没有创建出线程，严格来说，Java中创建线程的方式只有一种，那就是通过Thread类的start()方法来创建。</p><p>而所谓的实现Runnable、Callable接口、继承Thread类和根据线程池等来创建，这些方法本质上是创建了一个线程体，，也就是创建了一个给线程执行的任务，并不是真正的线程，它们的执行最终还是要依靠Thread类的start()方法来创建。</p><h2 id="线程的生命周期与状态"><a href="#线程的生命周期与状态" class="headerlink" title="线程的生命周期与状态"></a>线程的生命周期与状态</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有调用 <code>start()</code>。</li><li>RUNNABLE: 运行中状态，线程被调用了 <code>start()</code>的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回，而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示线程已经运行完毕。</li></ul><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p><img src="../images/image-20240829193146294.png" alt="image-20240829193146294" style="zoom:80%;" /><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态。</p><p><strong>为什么 JVM 没有区分这两种状态呢？</strong></p><p>现在的操作系统一般都是使用所谓的“时间分片”方式进行抢占式轮转调度。这个时间分片通常很小，大约只有0到0.01秒之间（此时就是一个running状态）。时间分片用完后就要被切换下来放入调度队列的末尾等待再次被调用(此时就是一个ready状态)。线程切换的很快，区分这两种状态就没意义了。</p></blockquote><p><img src="/../images/image-20240829193208451.png" alt="image-20240829193208451"></p><p>线程进入等待状态，即线程因为某种原因放弃了CPU使用权，阻塞也分为几种情况：</p><ul><li>等待阻塞：运行的线程执行**<code>wait</code>方法<strong>，JVM会把当前线程放入到</strong>等待队列<strong>，此时处于</strong>WAITING状态**。</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么JVM会把当前的线程放入到锁池中，此时处于<strong>BLOCKED状态</strong>。</li><li>其他阻塞：运行的线程执行<code>Thread.sleep</code>或者<code>join</code>方法，或者发出了I&#x2F;O请求时，JVM会把当前线程设置为阻塞状态，当<code>sleep</code>结束<code>join</code>线程终止、I&#x2F;O处理完毕则线程恢复，此时处于<strong>TIMED_WAITING状态</strong>。</li></ul><h2 id="什么是线程上下文切换？"><a href="#什么是线程上下文切换？" class="headerlink" title="什么是线程上下文切换？"></a>什么是线程上下文切换？</h2><p>线程在执行过程中会有自己的运行条件和状态，比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会退出 CPU 的占用。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场(通过程序计数器可以进行恢复，程序计数器记录了线程执行到了哪个位置，在进行线程切换时，可以找到线程上次执行到了哪个位置)。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h2 id="Thread类中的sleep-方法和Object类中的wait-方法做对比："><a href="#Thread类中的sleep-方法和Object类中的wait-方法做对比：" class="headerlink" title="Thread类中的sleep()方法和Object类中的wait()方法做对比："></a>Thread类中的sleep()方法和Object类中的wait()方法做对比：</h2><p><strong>共同点：</strong>两者都可以暂停线程的执行。</p><p><strong>区别：</strong></p><ul><li><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁** 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li></ul><h3 id="为什么wait-方法不在Thread类中？"><a href="#为什么wait-方法不在Thread类中？" class="headerlink" title="为什么wait()方法不在Thread类中？"></a>为什么wait()方法不在Thread类中？</h3><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p><p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p><p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p><h3 id="直接调用Thread类中的run-方法可以吗？"><a href="#直接调用Thread类中的run-方法可以吗？" class="headerlink" title="直接调用Thread类中的run()方法可以吗？"></a>直接调用Thread类中的run()方法可以吗？</h3><p>不可以。直接调用run()方法，相当于主线程直接调用一个方法，不是一个多线程的操作。在多线程操作中，通过创建一个线程，调用start()方法后会自动运行线程中的run()方法，方法执行结束后线程会进入一个终止状态，这就是一个线程的大概生命周期。</p><p><strong>调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h2 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h2><ul><li><strong>提高并发性能：</strong>多线程使得程序在同一段时间内处理多个任务，这在处理I&#x2F;O密集型(网络请求、文件读写等)任务时尤其重要。当一个线程在等待I&#x2F;O操作完成时，其他线程可以继续执行，从而提高了程序的整体运行效率。</li><li><strong>提高cpu的利用率：</strong>在cpu密集型任务中，多线程可以充分利用多核处理器的能力。每个线程可以在不同的处理器上运行，从而提高cpu的利用率。</li><li><strong>异步编程：</strong>异步编程模式允许程序在等待某些操作完成的同时继续执行其他任务。例如，一个线程可以发起网络请求，而在等待响应期间，其他线程可以继续执行其他任务。</li><li><strong>改善用户体验：</strong>在图形用户界面（GUI）应用中，多线程可以使程序保持响应状态。例如，一个线程可以处理用户界面的交互，而另一个线程可以处理后台计算任务，这样用户就不会感觉到程序卡顿。</li></ul><h2 id="单核-CPU-支持-Java-多线程吗？"><a href="#单核-CPU-支持-Java-多线程吗？" class="headerlink" title="单核 CPU 支持 Java 多线程吗？"></a>单核 CPU 支持 Java 多线程吗？</h2><p>单核 CPU 是支持 Java 多线程的。操作系统通过时间片轮转的方式，将 CPU 的时间分配给不同的线程。尽管单核 CPU 一次只能执行一个任务，但通过快速在多个线程之间切换，可以让用户感觉多个任务是同时进行的。</p><p>操作系统主要通过两种线程调度方式来管理多线程的执行：</p><ul><li><strong>抢占式调度（Preemptive Scheduling）</strong>：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。这种切换通常是由系统时钟中断（时间片轮转）或其他高优先级事件（如 I&#x2F;O 操作完成）触发的。这种方式存在上下文切换开销，但公平性和 CPU 资源利用率较好，不易阻塞。</li><li><strong>协同式调度（Cooperative Scheduling）</strong>：线程执行完毕后，主动通知系统切换到另一个线程。这种方式可以减少上下文切换带来的性能开销，但公平性较差，容易阻塞。</li></ul><p>Java 使用的线程调度是抢占式的。也就是说，JVM 本身不负责线程的调度，而是将线程的调度委托给操作系统。操作系统通常会基于线程优先级和时间片来调度线程的执行，高优先级的线程通常获得 CPU 时间片的机会更多。</p><h2 id="线程类型："><a href="#线程类型：" class="headerlink" title="线程类型："></a>线程类型：</h2><p>cpu密集型：线程主要进行计算逻辑处理，需要占用大量cpu资源。</p><p>i&#x2F;o密集型：线程主要进行大量输入输出操作，如文件的读取、网络通讯等，需要等待i&#x2F;o设备的响应，不需要占用cpu资源。</p><h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="/../images/image-20240829193230193.png" alt="image-20240829193230193"></p><p>产生死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="如何检测死锁？"><a href="#如何检测死锁？" class="headerlink" title="如何检测死锁？"></a>如何检测死锁？</h3><ul><li>使用<code>jmap</code>、<code>jstack</code>等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，<code>jstack</code> 的输出中通常会有 <code>Found one Java-level deadlock:</code>的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用<code>top</code>、<code>df</code>、<code>free</code>等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。</li><li>采用 VisualVM、JConsole 等工具进行排查。</li></ul><h3 id="如何预防和避免线程死锁？"><a href="#如何预防和避免线程死锁？" class="headerlink" title="如何预防和避免线程死锁？"></a>如何预防和避免线程死锁？</h3><p><strong>如何预防死锁？</strong> 破坏死锁产生的必要条件即可：</p><ul><li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong>：按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ul><p><strong>如何避免死锁：</strong>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><blockquote><p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p></blockquote><p>预防死锁可以完全避免死锁的发送，缺点是可能会降低系统的灵活性和效率。避免死锁是指系统可能存在发送死锁的情况，但通过算法或其他程序阻止死锁的发生，比如拒绝发生死锁的线程，避免死锁的优点是保持了一定的灵活性，缺点是增加了系统的复杂性，可能存在误判导致资源浪费。</p><h2 id="池化技术："><a href="#池化技术：" class="headerlink" title="池化技术："></a>池化技术：</h2><p>池化技术就是将可重复利用的对象比如链接、线程等统一管理起来。线程池、数据库连接池HTTP、Redis连接池等等都是对池化技术的应用。通常来说，池化技术所管理的对象，无论是连接还是线程，它们的创建过程都比较耗时，也比较消耗系统资源。所以把它们放到一个池子管理起来，以达到性能提升和资源复用的目的。</p><p>池化技术的核心思想就是以空间换时间。它的核心策略是使用已经创建好的对象来减少频繁创建对象带来的性能开销，同时还可以对对象进行统一的管理。</p><h3 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h3><p>线程池主要负责创建和管理线程。</p><p>没有线程池时，要用到线程就必须单独创建，用完之后再销毁。然而，线程的创建和销毁是比较耗费资源和时间的操作。</p><p>有了线程池后，可以重复利用已经创建好的线程降低线程创建和销毁造成的消耗。并且，线程池还可以对线程进行统一管理。</p><p><strong>线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。</strong></p><h4 id="Executor-框架介绍"><a href="#Executor-框架介绍" class="headerlink" title="Executor 框架介绍"></a>Executor 框架介绍</h4><p><code>Executor</code> 框架是 Java5 之后引进的，在 Java 5 之后，通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p><blockquote><p>this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><p><code>Executor</code> 框架包括了线程池的管理，提供了线程工厂、队列以及拒绝策略等。</p><p><code>Executor</code> 框架结构主要由三大部分组成：</p><ul><li><strong>任务(<code>Runnable</code> &#x2F;<code>Callable</code>)</strong></li></ul><p>执行任务需要实现 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>。**<code>Runnable</code> 接口**或 <strong><code>Callable</code> 接口</strong> 实现类都可以被 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</p><ul><li><strong>任务的执行(<code>Executor</code>)</strong></li></ul><p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong><code>ExecutorService</code></strong> 接口。</p><p><img src="/../images/image-20240829193253517.png" alt="image-20240829193253517"></p><p>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</p><p><strong>注意：</strong> 通过查看 <code>ScheduledThreadPoolExecutor</code> 源代码我们发现 <code>ScheduledThreadPoolExecutor</code> 实际上是继承了 <code>ThreadPoolExecutor</code> 并实现了 <code>ScheduledExecutorService</code> ，而 <code>ScheduledExecutorService</code> 又实现了 <code>ExecutorService</code>，正如我们上面给出的类关系图显示的一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//AbstractExecutorService实现了ExecutorService接口</span><br><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//ScheduledExecutorService继承ExecutorService接口</span><br><span class="line">public class ScheduledThreadPoolExecutor</span><br><span class="line">        extends ThreadPoolExecutor</span><br><span class="line">        implements ScheduledExecutorService</span><br></pre></td></tr></table></figure><ul><li><strong>异步计算的结果(<code>Future</code>)</strong></li></ul><p><strong><code>Future</code></strong> 接口以及 <code>Future</code> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</p><p>当我们把 <strong><code>Runnable</code>接口</strong> 或 <strong><code>Callable</code> 接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <code>submit()</code> 方法时会返回一个 <strong><code>FutureTask</code></strong> 对象）。</p><p><strong><code>Executor</code> 框架的使用示意图</strong>：</p><p><img src="https://javaguide.cn/assets/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE-8GKgMC9g.png" alt="Executor 框架的使用示意图"></p><ol><li>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</li><li>把创建完成的实现 <code>Runnable</code>&#x2F;<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li><li>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li><li>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</li></ol><p><strong>ExecutorService执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别：</strong></p><ul><li><p><code>execute()</code> 方法用于提交一个 <code>Runnable</code> 任务到线程池中执行。</p></li><li><p>它不会返回任何结果。</p></li><li><p><code>submit()</code> 方法用于提交一个 <code>Runnable</code> 或 <code>Callable</code> 任务到线程池中执行，并返回一个 <code>Future</code> 对象，可以用来获取任务的结果或检查任务的状态。</p></li><li><p>它可以处理 <code>Runnable</code> 和 <code>Callable</code> 类型的任务。</p></li></ul><h4 id="ThreadPoolExecutor-类介绍"><a href="#ThreadPoolExecutor-类介绍" class="headerlink" title="ThreadPoolExecutor 类介绍"></a>ThreadPoolExecutor 类介绍</h4><p>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</p><p><strong>线程池参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="line"> */</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量</span><br><span class="line">                          int maximumPoolSize,//线程池的最大线程数</span><br><span class="line">                          long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="line">                          TimeUnit unit,//时间单位</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="line">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="line">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="line">                           ) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code> 3 个最重要的参数：</p><ul><li><code>corePoolSize</code> : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><code>maximumPoolSize</code> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><code>workQueue</code>: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><code>keepAliveTime</code>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li><li><code>unit</code> : <code>keepAliveTime</code> 参数的时间单位。</li><li><code>threadFactory</code> :executor 创建新线程的时候会用到。</li><li><code>handler</code> :拒绝策略（后面会单独详细介绍一下）。</li></ul><img src="../images/image-20240829193330600.png" alt="image-20240829193330600" style="zoom:80%;" /><h5 id="ThreadPoolExecutor-拒绝策略定义"><a href="#ThreadPoolExecutor-拒绝策略定义" class="headerlink" title="ThreadPoolExecutor 拒绝策略定义:"></a><strong><code>ThreadPoolExecutor</code> 拒绝策略定义:</strong></h5><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolExecutor</code> 会执行一些拒绝策略:</p><ul><li><p><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</p></li><li><p><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</p></li></ul><p><code>ThreadPoolExecutor.CallerRunsPolicy</code> 是一种拒绝策略，它允许调用者的线程直接执行被拒绝的任务。调用者的线程指的是原本打算将任务提交给线程池的那个线程（即调用 <code>execute()</code> 方法的线程）</p><ul><li><p><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</p></li><li><p><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求。</p></li></ul><h5 id="ThreadPoolExecutor-AbortPolicy和ThreadPoolExecutor-DiscardPolicy的区别"><a href="#ThreadPoolExecutor-AbortPolicy和ThreadPoolExecutor-DiscardPolicy的区别" class="headerlink" title="ThreadPoolExecutor.AbortPolicy和ThreadPoolExecutor.DiscardPolicy的区别"></a><code>ThreadPoolExecutor.AbortPolicy</code>和<code>ThreadPoolExecutor.DiscardPolicy</code>的区别</h5><p><code>ThreadPoolExecutor.AbortPolicy</code></p><ul><li><strong>行为</strong>:<ul><li>当线程池无法接受更多任务时，<code>AbortPolicy</code> 会抛出 <code>RejectedExecutionException</code>，拒绝新任务的处理。</li><li>这意味着调用 <code>execute()</code> 方法的线程会接收到一个异常，表明任务无法被接受。</li></ul></li><li><strong>应用场景</strong>:<ul><li>通常用于开发阶段或测试环境中，以便快速发现线程池配置不当或资源不足的问题。</li><li>在生产环境中，如果需要保证系统稳定性，避免因为异常而导致系统崩溃，通常不建议使用此策略。</li></ul></li></ul><p><code>ThreadPoolExecutor.DiscardPolicy</code></p><ul><li><strong>行为</strong>:<ul><li>当线程池无法接受更多任务时，<code>DiscardPolicy</code> 会直接丢弃新任务，不会抛出异常。</li><li>这意味着调用 <code>execute()</code> 方法的线程不会接收到任何反馈，任务会被默默地丢弃。</li></ul></li><li><strong>应用场景</strong>:<ul><li>通常用于生产环境中，当线程池配置为最大容量时，如果系统资源已经饱和，那么丢弃任务可能是更好的选择。</li><li>适合于那些任务可以被丢弃且不会导致严重后果的情况。</li></ul></li></ul><h4 id="CallerRunsPolicy-拒绝策略有什么风险？如何解决？"><a href="#CallerRunsPolicy-拒绝策略有什么风险？如何解决？" class="headerlink" title="CallerRunsPolicy 拒绝策略有什么风险？如何解决？"></a>CallerRunsPolicy 拒绝策略有什么风险？如何解决？</h4><p>如果想要保证任何一个任务请求都要被执行的话，那选择 <code>CallerRunsPolicy</code> 拒绝策略更合适一些。</p><p>不过，如果走到<code>CallerRunsPolicy</code>的任务是个非常耗时的任务，且处理提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。</p><p>我们从问题的本质入手，调用者采用<code>CallerRunsPolicy</code>是希望所有的任务都能够被执行，暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中。这样的话，在内存允许的情况下，我们可以增加阻塞队列<code>BlockingQueue</code>的大小并调整堆内存以容纳更多的任务，确保任务能够被准确执行。</p><p>为了充分利用 CPU，我们还可以调整线程池的<code>maximumPoolSize</code> （最大线程数）参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</p><p><img src="/../images/image-20240829193356936.png" alt="image-20240829193356936"></p><p><strong>有没有办法既能保证任务不被丢弃且在服务器有余力时及时处理呢？</strong></p><p><strong>任务持久化</strong>的思路：</p><ol><li>设计一张任务表将任务存储到 MySQL 数据库中。</li></ol><ul><li>步骤 1: 设计任务表</li><li>步骤 2: 实现混合式阻塞队列，创建一个自定义的 <code>BlockingQueue</code> 实现类，该类将包含一个 <code>ArrayBlockingQueue</code> 和一个从数据库中读取任务的逻辑，重写 <code>take()</code> 方法，使其优先从数据库中读取任务，如果数据库中没有任务，则从 <code>ArrayBlockingQueue</code> 中取任务。</li><li>步骤 3: 实现拒绝策略，扩展 <code>ThreadPoolExecutor.CallerRunsPolicy</code> 并重写 <code>rejectedExecution()</code> 方法，以实现在任务被拒绝时将任务信息保存到数据库的功能。</li></ul><ol><li>Redis 缓存任务。</li><li>将任务提交到消息队列中。</li></ol><h4 id="线程池创建的两种方式"><a href="#线程池创建的两种方式" class="headerlink" title="线程池创建的两种方式"></a>线程池创建的两种方式</h4><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong><img src="https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-BR-2Ub-c.png" alt="通过构造方法实现"></p><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p><p><code>Executors</code>工具类提供的创建线程池的方法如下图所示：</p><p><img src="/../images/image-20240829193535012.png" alt="image-20240829193535012"></p><p>可以看出，通过<code>Executors</code>工具类可以创建多种类型的线程池，包括：</p><ul><li><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><code>SingleThreadExecutor</code>： 只有一个线程的线程池。若多于一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先进先出的顺序执行队列中的任务。</li><li><code>CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><p>《阿里巴巴 Java 开发手册》强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li><p><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>:使用的是无界的 <code>LinkedBlockingQueue</code>任务队列，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求任务，从而导致 OOM。</p></li><li><p><code>CachedThreadPool</code>:使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</p></li><li><p><code>ScheduledThreadPool</code>:使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 无界队列 LinkedBlockingQueue</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line"></span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 无界队列 LinkedBlockingQueue</span><br><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line"></span><br><span class="line">    return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE`</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line"></span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DelayedWorkQueue（延迟阻塞队列）</span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池常用的阻塞队列总结"><a href="#线程池常用的阻塞队列总结" class="headerlink" title="线程池常用的阻塞队列总结"></a>线程池常用的阻塞队列总结</h4><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。<code>FixedThreadPool</code>最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code>SingleThreadExector</code>只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。</li><li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li><li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><h4 id="线程池原理分析："><a href="#线程池原理分析：" class="headerlink" title="线程池原理分析："></a>线程池原理分析：</h4><p><code>executor.execute(worker)</code>这个方法非常重要，源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"></span><br><span class="line"> private static int workerCountOf(int c) &#123;</span><br><span class="line">     return c &amp; CAPACITY;</span><br><span class="line"> &#125;</span><br><span class="line"> //任务队列</span><br><span class="line"> private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"> public void execute(Runnable command) &#123;</span><br><span class="line">     // 如果任务为null，则抛出异常。</span><br><span class="line">     if (command == null)</span><br><span class="line">         throw new NullPointerException();</span><br><span class="line">     // ctl 中保存的线程池当前的一些状态信息</span><br><span class="line">     int c = ctl.get();</span><br><span class="line"></span><br><span class="line">     //  下面会涉及到 3 步 操作</span><br><span class="line">     // 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span><br><span class="line">     // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span><br><span class="line">     if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         if (addWorker(command, true))</span><br><span class="line">             return;</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     // 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里，表明创建新的线程失败。</span><br><span class="line">     // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span><br><span class="line">     if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         int recheck = ctl.get();</span><br><span class="line">         // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span><br><span class="line">         if (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line">             // 如果当前工作线程数量为0，新创建一个线程并执行。</span><br><span class="line">         else if (workerCountOf(recheck) == 0)</span><br><span class="line">             addWorker(null, false);</span><br><span class="line">     &#125;</span><br><span class="line">     //3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span><br><span class="line">     // 传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize</span><br><span class="line">     //如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span><br><span class="line">     else if (!addWorker(command, false))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>整个流程如下：</p><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><p><img src="/../images/image-20240829193616657.png" alt="image-20240829193616657"></p><p>在 <code>execute</code> 方法中，多次调用 <code>addWorker</code> 方法。<code>addWorker</code> 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。</p><h4 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a><code>Runnable</code> vs <code>Callable</code></h4><ul><li><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。</li><li><code>Runnable</code> 接口不会返回结果或抛出检查异常，但是 <code>Callable</code> 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <code>Runnable</code> 接口，这样代码看起来会更加简洁。</li></ul><p>工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）。</p><p><code>Runnable.java</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">   /**</span><br><span class="line">    * 被线程执行，没有返回值也无法抛出异常</span><br><span class="line">    */</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Callable.java</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 计算结果，或在无法这样做时抛出异常。</span><br><span class="line">     * @return 计算得出的结果</span><br><span class="line">     * @throws 如果无法计算结果，则抛出异常</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdown-VSshutdownNow"><a href="#shutdown-VSshutdownNow" class="headerlink" title="shutdown()VSshutdownNow()"></a><code>shutdown()</code>VS<code>shutdownNow()</code></h4><ul><li><p><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</p></li><li><p><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程池的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</p></li></ul><h4 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a><code>isTerminated()</code> VS <code>isShutdown()</code></h4><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h3 id="常见的内置线程池："><a href="#常见的内置线程池：" class="headerlink" title="常见的内置线程池："></a>常见的内置线程池：</h3><h4 id="FixedThreadPool介绍"><a href="#FixedThreadPool介绍" class="headerlink" title="FixedThreadPool介绍"></a>FixedThreadPool介绍</h4><p><code>FixedThreadPool</code> 被称为可重用固定线程数的线程池。通过 <code>Executors</code> 类中的相关源代码来看一下相关实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 创建一个可重用固定数量线程的线程池</span><br><span class="line">  */</span><br><span class="line"> public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">     return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                   0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>另外还有一个 <code>FixedThreadPool</code> 的实现方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源代码可以看出新创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 <code>nThreads</code>，这个 <code>nThreads</code> 参数是我们使用的时候自己传递的。</p><p>即使 <code>maximumPoolSize</code> 的值比 <code>corePoolSize</code> 大，也至多只会创建 <code>corePoolSize</code> 个线程。这是因为<code>FixedThreadPool</code> 使用的是容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列），队列永远不会被放满。</p><p><strong>因为线程池的执行流程是：</strong></p><p>当任务队列满了，比最大线程数小的话，会创建新的线程，但现在是一个<code>LinkedBlockingQueue</code>（无界队列），队列无法填满，也就无法创建新的线程。</p><h5 id="执行的任务流程："><a href="#执行的任务流程：" class="headerlink" title="执行的任务流程："></a>执行的任务流程：</h5><p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图</p><p><img src="https://javaguide.cn/assets/FixedThreadPool-C0OTNJpn.png" alt="FixedThreadPool的execute()方法运行示意图"></p><ol><li>如果当前运行的线程数小于 <code>corePoolSize</code>， 如果再来新任务的话，就创建新的线程来执行任务；</li><li>当前运行的线程数等于 <code>corePoolSize</code> 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</li><li>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li></ol><h5 id="不推荐使用FixedThreadPool"><a href="#不推荐使用FixedThreadPool" class="headerlink" title="不推荐使用FixedThreadPool"></a>不推荐使用<code>FixedThreadPool</code></h5><p><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响：</p><ol><li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code>；</li><li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li><li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li><li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li></ol><h4 id="SingleThreadExecutor介绍"><a href="#SingleThreadExecutor介绍" class="headerlink" title="SingleThreadExecutor介绍"></a>SingleThreadExecutor介绍</h4><p><code>SingleThreadExecutor</code> 是只有一个线程的线程池。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  *返回只有一个线程的线程池</span><br><span class="line">  */</span><br><span class="line"> public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">     return new FinalizableDelegatedExecutorService</span><br><span class="line">         (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">     return new FinalizableDelegatedExecutorService</span><br><span class="line">         (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面源代码可以看出新创建的 <code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1，其他参数和 <code>FixedThreadPool</code> 相同。</p><h5 id="执行任务流程："><a href="#执行任务流程：" class="headerlink" title="执行任务流程："></a>执行任务流程：</h5><p><img src="https://javaguide.cn/assets/SingleThreadExecutor-CWwRbYDP.png" alt="SingleThreadExecutor的运行示意图"></p><ol><li>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</li><li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></li><li>线程执行完当前的任务后，会在循环中反复从<code>LinkedBlockingQueue</code> 中获取任务来执行；</li></ol><h5 id="不推荐使用SingleThreadExecutor："><a href="#不推荐使用SingleThreadExecutor：" class="headerlink" title="不推荐使用SingleThreadExecutor："></a>不推荐使用<code>SingleThreadExecutor</code>：</h5><p><code>SingleThreadExecutor</code> 和 <code>FixedThreadPool</code> 一样，使用的都是容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）作为线程池的工作队列。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点，就是可能会导致 OOM。</p><h3 id="CachedThreadPool介绍"><a href="#CachedThreadPool介绍" class="headerlink" title="CachedThreadPool介绍"></a>CachedThreadPool介绍</h3><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span><br><span class="line"> */</span><br><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p><h5 id="执行任务流程：-1"><a href="#执行任务流程：-1" class="headerlink" title="执行任务流程："></a>执行任务流程：</h5><p><img src="https://javaguide.cn/assets/CachedThreadPool-execute-CmSVV1Ww.png" alt="CachedThreadPool的execute()方法的执行示意图"></p><ol><li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 offer 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成，否则执行下面的步骤 2；</li><li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，execute 方法执行完成；</li></ol><h5 id="不推荐使用-CachedThreadPool"><a href="#不推荐使用-CachedThreadPool" class="headerlink" title="不推荐使用&#96;CachedThreadPool"></a>不推荐使用&#96;CachedThreadPool</h5><p><code>CachedThreadPool</code> 使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</p><h4 id="ScheduledThreadPool介绍"><a href="#ScheduledThreadPool介绍" class="headerlink" title="ScheduledThreadPool介绍"></a>ScheduledThreadPool介绍</h4><p><code>ScheduledThreadPool</code> 用来在给定的延迟后运行任务或者定期执行任务。</p><h3 id="线程池的最佳实践"><a href="#线程池的最佳实践" class="headerlink" title="线程池的最佳实践"></a>线程池的最佳实践</h3><h4 id="正确声明线程池"><a href="#正确声明线程池" class="headerlink" title="正确声明线程池"></a>正确声明线程池</h4><p><strong>线程池必须手动通过 <code>ThreadPoolExecutor</code> 的构造函数来声明，避免使用<code>Executors</code> 类创建线程池，会有 OOM 风险。</strong></p><p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p><ul><li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li></ul><h4 id="监控线程池的运行状态"><a href="#监控线程池的运行状态" class="headerlink" title="监控线程池的运行状态"></a>监控线程池的运行状态</h4><p>可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 Actuator 组件。除此之外，还可以利用 <code>ThreadPoolExecutor</code> 的相关 API 做一个简陋的监控。从下图可以看出， <code>ThreadPoolExecutor</code>提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。</p><p><img src="/../images/image-20240829193651536.png" alt="image-20240829193651536"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程池的状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadPool 线程池对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printThreadPoolStatus</span><span class="params">(ThreadPoolExecutor threadPool)</span> &#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, createThreadFactory(<span class="string">&quot;print-images/thread-pool-status&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">    scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;ThreadPool Size: [&#123;&#125;]&quot;</span>, threadPool.getPoolSize());</span><br><span class="line">        log.info(<span class="string">&quot;Active Threads: &#123;&#125;&quot;</span>, threadPool.getActiveCount());</span><br><span class="line">        log.info(<span class="string">&quot;Number of Tasks : &#123;&#125;&quot;</span>, threadPool.getCompletedTaskCount());</span><br><span class="line">        log.info(<span class="string">&quot;Number of Tasks in Queue: &#123;&#125;&quot;</span>, threadPool.getQueue().size());</span><br><span class="line">        log.info(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同类别的业务用不同的线程池"><a href="#不同类别的业务用不同的线程池" class="headerlink" title="不同类别的业务用不同的线程池"></a>不同类别的业务用不同的线程池</h4><p>一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。</p><p>问题：</p><p><img src="/../images/image-20240829193712308.png" alt="image-20240829193712308"></p><p>试想这样一种极端情况：假如我们线程池的核心线程数为 <strong>n</strong>，父任务（扣费任务）数量为 <strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 <strong>“死锁”</strong> </p><p><img src="/../images/image-20240829193731990.png" alt="image-20240829193731990"></p><p><strong>解决方法也很简单，就是新增加一个用于执行子任务的线程池专门为其服务。</strong></p><h4 id="给线程池命名"><a href="#给线程池命名" class="headerlink" title="给线程池命名"></a>给线程池命名</h4><p>初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。</p><p>给线程池里的线程命名通常有下面两种方式：</p><p><strong>1、利用 guava 的 <code>ThreadFactoryBuilder</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure><p><strong>2、自己实现 <code>ThreadFactory</code>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正确配置线程池参数"><a href="#正确配置线程池参数" class="headerlink" title="正确配置线程池参数"></a>正确配置线程池参数</h4><h5 id="常规操作："><a href="#常规操作：" class="headerlink" title="常规操作："></a>常规操作：</h5><p>并不是线程池配置的越大越好，线程的数量过多会增加线程间的上下文切换的成本。</p><blockquote><p>上下文切换：</p><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><p>线程池大小设置过大或者过小都会有问题，合适的才是最好</p><ul><li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</li><li>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li></ul><p>有一个简单并且适用面比较广的公式：</p><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><p><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p><p><strong>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</strong></p><p>线程数更严谨的计算的方法应该是：<code>最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间））</code>，其中 <code>WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）</code>。</p><p>线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。</p><p>我们可以通过 JDK 自带的工具 VisualVM 来查看 <code>WT/ST</code> 比例。</p><p>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）&#x3D; N，和我们上面说的 N（CPU 核心数）+1 差不多。</p><p>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT&#x2F;ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</p><h5 id="动态更新线程池："><a href="#动态更新线程池：" class="headerlink" title="动态更新线程池："></a>动态更新线程池：</h5><p>借助现成的开源项目**<a href="https://github.com/opengoofy/hippo4j">Hippo4j</a><strong>和</strong><a href="https://github.com/dromara/dynamic-tp">Dynamic TP</a>**实现动态修改线程池参</p><p><img src="/../images/image-20240829193752553.png" alt="image-20240829193752553"></p><h4 id="别忘记关闭线程池"><a href="#别忘记关闭线程池" class="headerlink" title="别忘记关闭线程池"></a>别忘记关闭线程池</h4><p>当线程池不再需要使用时，应该显式地关闭线程池，释放线程资源。</p><p>线程池提供了两个关闭方法：</p><ul><li><p><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</p></li><li><p><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程池的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，停止处理排队的任务并返回正在等待执行的 List。</p></li></ul><p>调用完 <code>shutdownNow</code> 和 <code>shuwdown</code> 方法后，并不代表线程池已经完成关闭操作，它只是异步的通知线程池进行关闭处理。如果要同步等待线程池彻底关闭后才继续往下执行，需要调用<code>awaitTermination</code>方法进行同步等待。</p><p>在调用 <code>awaitTermination()</code> 方法时，应该设置合理的超时时间，以避免程序长时间阻塞而导致性能问题。另外。由于线程池中的任务可能会被取消或抛出异常，因此在使用 <code>awaitTermination()</code> 方法时还需要进行异常处理。<code>awaitTermination()</code> 方法会抛出 <code>InterruptedException</code> 异常，需要捕获并处理该异常，以避免程序崩溃或者无法正常退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">executor.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 等待线程池关闭，最多等待5分钟</span></span><br><span class="line">    <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">5</span>, TimeUnit.MINUTES)) &#123;</span><br><span class="line">        <span class="comment">// 如果等待超时，则打印日志</span></span><br><span class="line">        System.err.println(<span class="string">&quot;线程池未能在5分钟内完全关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池不要放耗时任务"><a href="#线程池不要放耗时任务" class="headerlink" title="线程池不要放耗时任务"></a>线程池不要放耗时任务</h4><p>线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。</p><p>对于一些比较耗时的操作，如网络请求、文件读写等，可以采用 <code>CompletableFuture</code> 等其他异步操作的方式来处理，以避免阻塞线程池中的线程。</p><h4 id="不要重复创建线程池"><a href="#不要重复创建线程池" class="headerlink" title="不要重复创建线程池"></a>不要重复创建线程池</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Future类介绍&quot;&gt;&lt;a href=&quot;#Future类介绍&quot; class=&quot;headerlink&quot; title=&quot;Future类介绍&quot;&gt;&lt;/a&gt;Future类介绍&lt;/h2&gt;&lt;p&gt;Future是异步思想的典型应用，主要用在一些需要执行耗时操作任务的场景，避免线程一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>并发编程</title>
    <link href="http://example.com/2024/08/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/08/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-08-29T11:23:54.060Z</published>
    <updated>2024-08-29T11:30:33.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指令重排："><a href="#指令重排：" class="headerlink" title="指令重排："></a>指令重排：</h2><p>为了提升执行速度和性能，计算机在执行程序代码的时候，会对指令进行重排序。</p><p><strong>指令重排序简单来说就是系统在执行代码的时候并不是按照你写代码的顺序依次顺序执行的。</strong></p><p>常见的指令重排有以下两种情况：</p><p><strong>编译器优化重排</strong>：编译器在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p><p><strong>指令并行重排</strong>：现代处理器采用指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p><p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p><p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p><p><strong>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性</strong>。</p><h2 id="并发编程的三个重要特性："><a href="#并发编程的三个重要特性：" class="headerlink" title="并发编程的三个重要特性："></a>并发编程的三个重要特性：</h2><p><strong>原子性</strong></p><p>一次或多次操作，要么所有操作都得到执行且不会受到任何因素的干扰而中断，要么所有操作都不执行。</p><p>在Java中可以借助synchronized和各种lock以及各种原子类实现原子性。</p><p><code>synchronized</code>和各种<code>lock</code>可以保证任意时刻只有一个线程可以访问该代码块，因此保证了原子性。各种原子类是利用CAS操作(可能也会用到<code>volatile</code>或者<code>final</code>关键字)来保证原子操作。</p><p><strong>可见性</strong></p><p>当一个线程对共享变量的值进行了修改，那么其他的线程是可以立刻查看到修改后的新值的。</p><p>在Java中可以借助synchronized、volatile和各种lock来实现可见性。</p><p>如果变量使用了volatile关键字进行修饰，这就指示了JVM这个变量是共享的且不稳定的，每次使用它都到主存中进行读取。</p><p><strong>有序性</strong></p><p>由于指令重排的问题，代码的执行顺序未必就是代码的编写的顺序。</p><p>代码重排可以保证串行语义的一致，但是没有义务保证多线程间的语义也一致。</p><p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p><h2 id="volatile关键字："><a href="#volatile关键字：" class="headerlink" title="volatile关键字："></a>volatile关键字：</h2><h3 id="如何保证变量的可见性？"><a href="#如何保证变量的可见性？" class="headerlink" title="如何保证变量的可见性？"></a>如何保证变量的可见性？</h3><p>在Java中，volatile关键字可以保证变量的可见性，如果将变量用volatile关键字修饰，这就告诉jvm，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><img src="../images/image-20240829192626481.png" alt="image-20240829192626481" style="zoom:80%;" /><p><img src="/../images/image-20240829192651173.png" alt="image-20240829192651173"></p><p>volatile关键字并非Java中特有的，在C语言中也有，它最原始的意义就是禁用CPU缓存。如果将一个变量用volatile关键字修饰，这就指示编译器，这个变量是共享且不稳定的，每次使用它都要到主存中获取。</p><p>volatile关键字能保证数据的可见性，不能保证数据的原子性。synchronized两者都能保证。</p><h3 id="防止指令重排："><a href="#防止指令重排：" class="headerlink" title="防止指令重排："></a>防止指令重排：</h3><p><strong>在Java中，volatile关键字还可以保证指令的重排序。如果我们将变量声明为volatile关键字修饰，在对这个变量进行读写操作时，会通过插入特定的内存屏障的方式来禁止指令重排。</strong></p><p>在 Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public native void loadFence();</span><br><span class="line">public native void storeFence();</span><br><span class="line">public native void fullFence();</span><br></pre></td></tr></table></figure><p>理论上来说，通过这个三个方法也可以实现和<code>volatile</code>禁止重排序一样的效果，只是会麻烦一些。</p><p><strong>单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理</strong>：</p><p><strong>双重校验锁实现对象单例（线程安全）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为<code>uniqueInstance</code>分配内存空间</li><li>初始化<code>uniqueInstance</code></li><li>将<code>uniqueInstance</code>指向分配的内存空间。</li></ol><p>但是由于JVM具有指令重排的特性，执行的顺序可能会变成1，3，2。指令重排在单线程环境下不会出现问题，但在多线程环境下，会出现一个线程读取到了一个还没初始化的对象。它的过程是：</p><p>1.为<code>uniqueInstance</code>分配内存空间。</p><p>2.将<code>uniqueInstance</code>指向分配的内存空间。</p><p>3.此时，另一个线程发现<code>uniqueInstance</code>不为null，直接返回。</p><p>4.得到一个没有初始化的对象。</p><h3 id="volatile可以保证原子性吗？"><a href="#volatile可以保证原子性吗？" class="headerlink" title="volatile可以保证原子性吗？"></a>volatile可以保证原子性吗？</h3><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 微信搜 JavaGuide 回复&quot;面试突击&quot;即可免费领取个人原创的 Java 面试手册</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Guide哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/08/03 13:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatileAtomicityDemo</span> <span class="variable">volatileAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatileAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，运行上面的代码理应输出 <code>2500</code>。但实际运行后结果小于2500。</p><p><code>volatile</code> 可以保证变量的可见性，也就是说，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500&#x3D;2500。</p><p><code>inc++</code>是一个复合操作，主要包括：</p><ol><li>读取inc的值</li><li>对inc+1</li><li>回写inc的值到内存</li></ol><p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p><ol><li>线程1对inc的值进行读取，但还未做修改。线程2此时读取inc的值进行+1操作，回写inc的值。</li><li>线程1此时对inc的值+1，回写数据。</li><li>结果inc的值为1，少了一次+1操作。</li></ol><p>利用 <code>synchronized</code>、<code>Lock</code>或者<code>AtomicInteger</code>来进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h3><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问都会出现问题(比如数据被修改)，所以每次在获取共享资源的时候都会加锁，这样其他线程只能阻塞等待上一个持有锁的线程释放该锁。也就是说，共享资源每次只能给一个线程使用，其他线程只能阻塞等待，只有持有锁的线程释放锁，其他线程才能抢锁进行逻辑。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><h3 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h3><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p><p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><p><img src="/../images/image-20240829192715970.png" alt="image-20240829192715970"></p><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p><h3 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h3><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p><h4 id="版本号机制："><a href="#版本号机制：" class="headerlink" title="版本号机制："></a>版本号机制：</h4><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子</strong>：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code>&#x3D;1 ），连同帐户扣除后余额（ <code>balance</code>&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号（ <code>version</code>&#x3D;1 ）试图向数据库提交数据（ <code>balance</code>&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol><p>这样就避免了操作员 B 用基于 <code>version</code>&#x3D;1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p><h4 id="CAS算法："><a href="#CAS算法：" class="headerlink" title="CAS算法："></a>CAS算法：</h4><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p><blockquote><p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p></blockquote><p>CAS 涉及到三个操作数：</p><ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)</li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p><p><strong>举一个简单的例子</strong>：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。</p><ol><li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li><li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li></ol><p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。</p><p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *  CAS</span></span><br><span class="line"><span class="comment">  *  <span class="doctag">@param</span> o         包含要修改field的对象</span></span><br><span class="line"><span class="comment">  *  <span class="doctag">@param</span> offset    对象中某field的偏移量</span></span><br><span class="line"><span class="comment">  *  <span class="doctag">@param</span> expected  期望值</span></span><br><span class="line"><span class="comment">  *  <span class="doctag">@param</span> update    更新值</span></span><br><span class="line"><span class="comment">  *  <span class="doctag">@return</span>          true | false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,  Object expected, Object update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected,<span class="type">int</span> update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br></pre></td></tr></table></figure><h4 id="Java中的CAS是怎么实现的？"><a href="#Java中的CAS是怎么实现的？" class="headerlink" title="Java中的CAS是怎么实现的？"></a>Java中的CAS是怎么实现的？</h4><p>在 Java 中，实现 CAS（Compare-And-Swap, 比较并交换）操作的一个关键类是<code>Unsafe</code>。</p><p><code>Unsafe</code>类位于<code>sun.misc</code>包下，是一个提供低级别、不安全操作的类。由于其强大的功能和潜在的危险性，它通常用于 JVM 内部或一些需要极高性能和底层访问的库中，而不推荐普通开发者在应用程序中使用。</p><p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式更新对象字段的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o        要操作的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset   对象字段的内存偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expected 期望的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x        要设置的新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果值被成功更新，则返回 true；否则返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object expected, Object x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式更新 int 类型的对象字段的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式更新 long 类型的对象字段的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> x)</span>;</span><br></pre></td></tr></table></figure><p><code>Unsafe</code>类中的 CAS 方法是<code>native</code>方法。<code>native</code>关键字表明这些方法是用本地代码（通常是 C 或 C++）实现的，而不是用 Java 实现的。这些方法直接调用底层的硬件指令来实现原子操作。也就是说，Java 语言并没有直接用 Java 实现 CAS，而是通过 C++ 内联汇编的形式实现的（通过 JNI 调用）。因此，CAS 的具体实现与操作系统以及 CPU 密切相关。</p><p><code>java.util.concurrent.atomic</code> 包提供了一些用于原子操作的类。这些类利用底层的原子指令，确保在多线程环境下的操作是线程安全的。</p><p><img src="/../images/image-20240829192741641.png" alt="image-20240829192741641"></p><p><code>AtomicInteger</code>是 Java 的原子类之一，主要用于对 <code>int</code> 类型的变量进行原子操作，它利用<code>Unsafe</code>类提供的低级别原子操作方法实现无锁的线程安全性。</p><p><code>AtomicInteger</code>核心源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Unsafe 实例</span><br><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取“value”字段在AtomicInteger类中的内存偏移量</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 确保“value”字段的可见性</span><br><span class="line">private volatile int value;</span><br><span class="line"></span><br><span class="line">// 如果当前值等于预期值，则原子地将值设置为newValue</span><br><span class="line">// 使用 Unsafe#compareAndSwapInt 方法进行CAS操作</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原子地将当前值加 delta 并返回旧值</span><br><span class="line">public final int getAndAdd(int delta) &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原子地将当前值加 1 并返回加之前的值（旧值）</span><br><span class="line">// 使用 Unsafe#getAndAddInt 方法进行CAS操作。</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原子地将当前值减 1 并返回减之前的值（旧值）</span><br><span class="line">public final int getAndDecrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Unsafe#getAndAddInt</code>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 原子地获取并增加整数值</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 以 volatile 方式获取对象 o 在内存偏移量 offset 处的整数值</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    // 返回旧值</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>getAndAddInt</code> 使用了 <code>do-while</code> 循环：在<code>compareAndSwapInt</code>操作失败时，会不断重试直到成功。也就是说，<code>getAndAddInt</code>方法会通过 <code>compareAndSwapInt</code> 方法来尝试更新 <code>value</code> 的值，如果更新失败（当前值在此期间被其他线程修改），它会重新获取当前值并再次尝试更新，直到操作成功。</p><p>由于 CAS 操作可能会因为并发冲突而失败，因此通常会与<code>while</code>循环搭配使用，在失败后不断重试，直到操作成功。这就是<strong>自旋锁机制</strong> </p><h4 id="CAS算法存在哪些问题？"><a href="#CAS算法存在哪些问题？" class="headerlink" title="CAS算法存在哪些问题？"></a>CAS算法存在哪些问题？</h4><p>ABA 问题是 CAS 算法最常见的问题。</p><h5 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h5><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V   expectedReference,</span></span><br><span class="line"><span class="params">                             V   newReference,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> expectedStamp,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> newStamp)</span> &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h5><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><p>如果 JVM 能够支持处理器提供的<code>pause</code>指令，那么自旋操作的效率将有所提升。<code>pause</code>指令有两个重要作用：</p><p><strong>延迟流水线执行指令</strong>：<code>pause</code>指令可以延迟指令的执行，从而减少 CPU 的资源消耗。具体的延迟时间取决于处理器的实现版本，在某些处理器上，延迟时间可能为零。</p><p><strong>避免内存顺序冲突</strong>：在退出循环时，<code>pause</code>指令可以避免由于内存顺序冲突而导致的 CPU 流水线被清空，从而提高 CPU 的执行效率。</p><h5 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h5><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p><p>除了 <code>AtomicReference</code> 这种方式之外，还可以利用加锁来保证。</p><h2 id="如何使用Synchronized"><a href="#如何使用Synchronized" class="headerlink" title="如何使用Synchronized"></a>如何使用Synchronized</h2><p>synchronized的使用方式有三种：</p><ol><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ol><h3 id="1-修饰实例方法-锁当前对象实例"><a href="#1-修饰实例方法-锁当前对象实例" class="headerlink" title="1.修饰实例方法(锁当前对象实例)"></a>1.修饰实例方法(锁当前对象实例)</h3><p>给当前对象实例加锁，进入同步代码前要获取当前对象实例的锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized void method() &#123;</span><br><span class="line">    //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-修饰静态方法（锁当前类）"><a href="#2-修饰静态方法（锁当前类）" class="headerlink" title="2.修饰静态方法（锁当前类）"></a>2.修饰静态方法（锁当前类）</h3><p>给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获取当前class的锁。</p><p>这是因为静态成员不属于任何一个实例对象，而是归整个类所有，不依赖于类的特定实例，被类的所有实例所共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p><h3 id="3、修饰代码块-（锁指定对象-类）"><a href="#3、修饰代码块-（锁指定对象-类）" class="headerlink" title="3、修饰代码块 （锁指定对象&#x2F;类）"></a><strong>3、修饰代码块</strong> （锁指定对象&#x2F;类）</h3><p>对括号里指定的对象&#x2F;类加锁：</p><ul><li><p><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</p></li><li><p><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</p></li><li><p><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</p></li><li><p>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</p></li></ul><p><strong>构造方法不能用synchronized关键字修饰，但可以在方法内部使用synchronized代码块。</strong></p><h3 id="synchronized-底层原理了解吗？"><a href="#synchronized-底层原理了解吗？" class="headerlink" title="synchronized 底层原理了解吗？"></a>synchronized 底层原理了解吗？</h3><p>synchronized 关键字底层原理属于 JVM 层面的东西。</p><h4 id="synchronized-同步代码块的情况"><a href="#synchronized-同步代码块的情况" class="headerlink" title="synchronized 同步代码块的情况"></a>synchronized 同步代码块的情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK 自带的 <code>javap</code> 命令查看 <code>SynchronizedDemo</code> 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p><img src="../images/image-20240829192830518.png" alt="image-20240829192830518" style="zoom:80%;" /><p>从上面可以看出：**<code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。**</p><p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><img src="../images/image-20240829192853118.png" alt="image-20240829192853118" style="zoom:80%;" /><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><img src="../images/image-20240829192915179.png" alt="image-20240829192915179" style="zoom:80%;" /><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h4 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a>synchronized 修饰方法的的情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20240829192938145.png" alt="image-20240829192938145"></p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><h4 id="JDK1-6-之后的-synchronized-底层做了哪些优化？锁升级原理了解吗？"><a href="#JDK1-6-之后的-synchronized-底层做了哪些优化？锁升级原理了解吗？" class="headerlink" title="JDK1.6 之后的 synchronized 底层做了哪些优化？锁升级原理了解吗？"></a>JDK1.6 之后的 synchronized 底层做了哪些优化？锁升级原理了解吗？</h4><p>在 Java 6 之后， <code>synchronized</code> 引入了大量的锁优化，如增加了自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h3 id="synchronized-和-volatile-有什么区别？"><a href="#synchronized-和-volatile-有什么区别？" class="headerlink" title="synchronized 和 volatile 有什么区别？"></a>synchronized 和 volatile 有什么区别？</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li><li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h2 id="ReentranLock"><a href="#ReentranLock" class="headerlink" title="ReentranLock"></a>ReentranLock</h2><p><strong>共享锁：</strong></p><ul><li>多个事务可以同时获取同一数据项上的共享锁，即多个读操作可以同时进行。</li><li>一旦某个数据项上有共享锁，其他事务不能对该数据项加独占锁，直到所有共享锁被释放。</li><li>当一个事务获取了一个数据项的共享锁后，它可以读取该数据项，但不能修改它。</li><li>果一个事务想要修改数据，它必须等待所有对该数据的共享锁都被释放。</li></ul><p><strong>独占锁：</strong></p><ul><li><p>一个事务获取了独占锁后，其他事务不能对该数据项进行任何读写操作，直到该独占锁被释放。</p></li><li><p>一次只能有一个事务获取一个数据项的独占锁。</p></li><li><p>一旦某个数据项上有独占锁，其他事务不能对该数据项加共享锁或独占锁，直到独占锁被释放。</p></li><li><p>如果一个事务想要修改数据，它必须获取该数据项的独占锁。</p></li><li><p>持有独占锁的事务可以读取并修改数据</p></li></ul><p><strong>公平锁：</strong></p><ul><li>公平锁是按照线程请求获取锁的时间顺序来决定哪个能得到锁。</li><li>试图获取锁的线程会按照它们请求获取锁的时间进行排序。</li><li>当锁被释放时，最先进入队列的线程会优先获取锁，类似先到先得的原则。</li></ul><p><strong>非公平锁：</strong></p><ul><li>非公平锁并不严格按照获取锁的时间顺序来获取锁。</li><li>当持有锁的线程释放了锁时，该线程仍然可能获取到锁。</li><li>在某些情况下，新的线程可能会插队来获取锁，导致先到的线程等待更长的时间。</li><li>这种机制可能会<strong>减少获取锁的延迟</strong>，线程不需要总是等待队列中的所有线程都尝试过获取锁。</li><li>通常情况下，非公平锁比公平锁的性能更好，因为它减少了线程之间的竞争。</li></ul><h3 id="ReentranLock是什么"><a href="#ReentranLock是什么" class="headerlink" title="ReentranLock是什么"></a>ReentranLock是什么</h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><img src="/../images/image-20240829193008262.png" alt="image-20240829193008262"></p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的内容可以看出， <code>ReentrantLock</code> 的底层就是由 AQS 来实现的。</p><h3 id="Synchronized和ReentranLock的区别是什么？"><a href="#Synchronized和ReentranLock的区别是什么？" class="headerlink" title="Synchronized和ReentranLock的区别是什么？"></a>Synchronized和ReentranLock的区别是什么？</h3><h4 id="两者都是可重复锁"><a href="#两者都是可重复锁" class="headerlink" title="两者都是可重复锁"></a>两者都是可重复锁</h4><p><strong>可重入锁 也叫递归锁，指的是线程在获取锁之后，在内部还可以获取同一把锁。</strong>比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p><p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是<strong>可重入</strong>的。</p><h4 id="synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h4><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p><p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><h4 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h4><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><p><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。</p><p><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</p><h4 id="condition接口的介绍："><a href="#condition接口的介绍：" class="headerlink" title="condition接口的介绍："></a>condition接口的介绍：</h4><p>Condition是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，而用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而Condition实例的signalAll()方法，只会唤醒注册在该Condition实例中的所有等待线程。</p><p><strong>步骤 1: 创建 <code>ReentrantLock</code> 和 <code>Condition</code> 实例</strong></p><p>首先，需要创建一个 <code>ReentrantLock</code> 实例，并使用该锁创建一个或多个 <code>Condition</code> 实例。每个 <code>Condition</code> 实例将对应一个特定的条件，线程可以根据需要注册到不同的条件上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectiveNotifyExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SelectiveNotifyExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SelectiveNotifyExample</span>();</span><br><span class="line">        example.runExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runExample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread A waiting on conditionA at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">                conditionA.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread A notified at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread B waiting on conditionB at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">                conditionB.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread B notified at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">notifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Notifying conditionA at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">                conditionA.signalAll(); <span class="comment">// 通知所有在conditionA上等待的线程</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Notifying conditionB at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">                conditionB.signalAll(); <span class="comment">// 通知所有在conditionB上等待的线程</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Notifier&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 给线程A和线程B一点时间等待</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        notifier.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤 2: 使用 <code>await()</code> 和 <code>signalAll()</code> 方法</strong></p><ul><li><p><strong><code>await()</code></strong> 方法：线程调用此方法后，会释放锁并等待，直到其他线程调用相应的 <code>Condition</code> 实例的 <code>signal()</code> 或 <code>signalAll()</code> 方法。</p></li><li><p><strong><code>signalAll()</code></strong> 方法：调用此方法后，会唤醒所有等待在该 <code>Condition</code> 实例上的线程。如果线程之前因为调用 <code>await()</code> 方法而释放了锁，那么在被唤醒后会重新获取锁。</p></li></ul><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread A waiting on conditionA at <span class="number">1698057770359</span></span><br><span class="line">Thread B waiting on conditionB at <span class="number">1698057770360</span></span><br><span class="line">Notifying conditionA at <span class="number">1698057771360</span></span><br><span class="line">Thread A notified at <span class="number">1698057771360</span></span><br><span class="line">Notifying conditionB at <span class="number">1698057771360</span></span><br><span class="line">Thread B notified at <span class="number">1698057771360</span></span><br></pre></td></tr></table></figure><p>使用 <code>ReentrantLock</code> 和 <code>Condition</code> 实例，我们可以实现更细粒度的线程通知控制。相比于 <code>synchronized</code> 关键字和 <code>wait()</code>&#x2F;<code>notify()</code> 方法，<code>Condition</code> 提供了更灵活的选择性通知能力，可以更好地控制哪些线程被唤醒以及何时唤醒它们。</p><h2 id="ReentrantReadWriteLock是什么？"><a href="#ReentrantReadWriteLock是什么？" class="headerlink" title="ReentrantReadWriteLock是什么？"></a>ReentrantReadWriteLock是什么？</h2><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>, java.io.Serializable&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</li><li>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</li></ul><p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p><p>和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。</p><p><img src="/../images/image-20240829193029944.png" alt="image-20240829193029944"></p><p><code>ReentrantReadWriteLock</code> 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantReadWriteLock-适用的场景："><a href="#ReentrantReadWriteLock-适用的场景：" class="headerlink" title="ReentrantReadWriteLock 适用的场景："></a><code>ReentrantReadWriteLock</code> 适用的场景：</h3><p>由于 <code>ReentrantReadWriteLock</code> 既可以保证<strong>多个线程同时读的效率</strong>，同时又可以保证有<strong>写入操作时的线程安全</strong>。因此，在<strong>读多写少</strong>的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能。</p><h3 id="读锁不能升级为写锁，写锁可以降级为读锁"><a href="#读锁不能升级为写锁，写锁可以降级为读锁" class="headerlink" title="读锁不能升级为写锁，写锁可以降级为读锁"></a>读锁不能升级为写锁，写锁可以降级为读锁</h3><p>因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</p><p>假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁</p><h2 id="StampedLock是什么？"><a href="#StampedLock是什么？" class="headerlink" title="StampedLock是什么？"></a>StampedLock是什么？</h2><p><code>StampedLock</code>是jdk1.8引用的，它不支持可重入，不支持条件变量<code>Condition</code>。</p><p><code>StampedLock</code>并不同于一般的锁，<code>StampedLock</code>并不是直接实现<code>Lock</code>和<code>ReadWriteLock</code>接口，它是基于<code>CLH</code>锁独立实现的（AQS也是基于这个实现的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLock</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StampedLock</code> 提供了三种模式的读写：读锁、写锁、乐观读</p><ul><li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</li><li><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是不可重入的。</li><li><strong>乐观读</strong>：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</li></ul><p><code>StampedLock</code> 还支持这三种锁在一定条件下进行相互转换 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">tryConvertToWriteLock</span><span class="params">(<span class="type">long</span> stamp)</span>&#123;&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">tryConvertToReadLock</span><span class="params">(<span class="type">long</span> stamp)</span>&#123;&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">tryConvertToOptimisticRead</span><span class="params">(<span class="type">long</span> stamp)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>StampedLock</code> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是<code>StampedLock</code>不可重入的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> s, next;  <span class="comment">// bypass acquireWrite in fully unlocked case only</span></span><br><span class="line">    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">            next : acquireWrite(<span class="literal">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">readLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> state, next;  <span class="comment">// bypass acquireRead on common uncontended case</span></span><br><span class="line">    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">            next : acquireRead(<span class="literal">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 乐观读</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> s;</span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StampedLock-的性能为什么更好"><a href="#StampedLock-的性能为什么更好" class="headerlink" title="StampedLock 的性能为什么更好"></a>StampedLock 的性能为什么更好</h3><p>相比于传统读写锁多出来的乐观读是<code>StampedLock</code>比 <code>ReadWriteLock</code> 性能更好的关键原因。<code>StampedLock</code> 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;指令重排：&quot;&gt;&lt;a href=&quot;#指令重排：&quot; class=&quot;headerlink&quot; title=&quot;指令重排：&quot;&gt;&lt;/a&gt;指令重排：&lt;/h2&gt;&lt;p&gt;为了提升执行速度和性能，计算机在执行程序代码的时候，会对指令进行重排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令重排序简</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>xxl-job</title>
    <link href="http://example.com/2024/08/29/xxl-job/"/>
    <id>http://example.com/2024/08/29/xxl-job/</id>
    <published>2024-08-29T11:23:54.059Z</published>
    <updated>2024-08-29T11:51:24.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xxl-job的定时功能底层是怎么实现？"><a href="#xxl-job的定时功能底层是怎么实现？" class="headerlink" title="xxl-job的定时功能底层是怎么实现？"></a>xxl-job的定时功能底层是怎么实现？</h2><p>XXL-Job 的定时功能底层实现了基于时间轮的调度模型，使用了调度中心和执行器组件来管理任务的调度和执行，并采用了分布式锁和故障恢复机制来保证任务执行的一致性和可靠性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;xxl-job的定时功能底层是怎么实现？&quot;&gt;&lt;a href=&quot;#xxl-job的定时功能底层是怎么实现？&quot; class=&quot;headerlink&quot; title=&quot;xxl-job的定时功能底层是怎么实现？&quot;&gt;&lt;/a&gt;xxl-job的定时功能底层是怎么实现？&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://example.com/2024/08/29/ThreadLocal/"/>
    <id>http://example.com/2024/08/29/ThreadLocal/</id>
    <published>2024-08-29T11:23:54.056Z</published>
    <updated>2024-08-29T07:34:43.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是弱引用？"><a href="#什么是弱引用？" class="headerlink" title="什么是弱引用？"></a>什么是弱引用？</h2><p>弱引用是Java中4大引用之一，是一种较为特殊且轻量级的引用类型。弱引用设计的目的是允许垃圾回收器在内存压力过大时，回收弱引用指向的对象，即使该对象仍然被弱引用所引用。</p><p><strong>弱引用的特点：</strong></p><ul><li>弱引用指向的对象的生命周期比软引用短，比虚引用长。</li><li>当垃圾回收器运行时，即使内存充足，被弱引用指向的对象仍然会被回收。</li><li>一旦被弱引用指向的对象被垃圾回收器回收，该弱引用就会自动被清空，变为 <code>null</code>。</li></ul><p><strong>弱引用的用途：</strong></p><ol><li><strong>缓存</strong>：弱引用常用于实现缓存机制，特别是当希望在内存紧张时能够自动释放缓存时。</li><li><strong>避免内存泄漏</strong>：使用弱引用可以帮助避免因循环引用等引起的内存泄漏问题。</li></ol><h2 id="ThreadLocal的原理："><a href="#ThreadLocal的原理：" class="headerlink" title="ThreadLocal的原理："></a>ThreadLocal的原理：</h2><ol><li><strong>变量副本</strong>：<code>ThreadLocal</code> 为每个线程创建一个独立的变量副本，这意味着每个线程都有自己的变量副本，这些副本之间是相互独立的。</li><li><strong>线程隔离</strong>：由于每个线程都有自己的变量副本，因此它们之间不会互相干扰，也不会发生数据竞争问题。</li><li><strong>存储机制</strong>：<code>ThreadLocal</code> 使用 Java 的 <code>Thread</code> 类中的一个名为 <code>threadLocals</code> 的 <code>ThreadLocalMap</code> 来存储每个线程的变量副本。</li></ol><h3 id="ThreadLocal-的实现细节"><a href="#ThreadLocal-的实现细节" class="headerlink" title="ThreadLocal 的实现细节"></a>ThreadLocal 的实现细节</h3><ol><li><strong>ThreadLocal 类</strong>：<code>ThreadLocal</code> 类提供了一个模板方法 <code>get()</code> 和 <code>set()</code> 来获取和设置线程局部变量的值。</li><li><strong>Thread 类</strong>：每个 <code>Thread</code> 对象都有一个 <code>ThreadLocalMap</code> 成员变量，用于存储线程局部变量的值。</li><li><strong>ThreadLocalMap</strong>：这是一个内部类，它负责存储 <code>ThreadLocal</code> 对象与线程局部变量值的映射关系。</li><li><strong>get() 方法</strong>：当调用 <code>get()</code> 方法时，<code>ThreadLocal</code> 会查找当前线程的 <code>ThreadLocalMap</code> 中对应的键值对，如果找不到，则返回默认值。</li><li><strong>set()方法</strong>：当调用 <code>set()</code> 方法时，<code>ThreadLocal</code> 会将当前线程与指定的值关联起来，存储在当前线程的 <code>ThreadLocalMap</code> 中。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是弱引用？&quot;&gt;&lt;a href=&quot;#什么是弱引用？&quot; class=&quot;headerlink&quot; title=&quot;什么是弱引用？&quot;&gt;&lt;/a&gt;什么是弱引用？&lt;/h2&gt;&lt;p&gt;弱引用是Java中4大引用之一，是一种较为特殊且轻量级的引用类型。弱引用设计的目的是允许垃圾回收器在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://example.com/2024/08/29/Redis/"/>
    <id>http://example.com/2024/08/29/Redis/</id>
    <published>2024-08-29T11:23:54.054Z</published>
    <updated>2024-08-29T11:51:17.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h2><ol><li>Redis 基于内存，内存的访问速度比磁盘快很多；</li><li>Redis 开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用</li><li>redis拥有高效的数据结构</li></ol><h2 id="为什么要用redis？"><a href="#为什么要用redis？" class="headerlink" title="为什么要用redis？"></a>为什么要用redis？</h2><p><strong>访问速度更快</strong></p><p>redis是一个纯内存操作，它将所有的数据都存储在内存中，而内存的访问速度远远高于磁盘存储。</p><p><strong>高并发</strong></p><p>因为Redis的所有的数据都存储在内存中，所以它的qps比Mysql这类的数据库的qps高得多。我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而提高系统的整体并发性。</p><p><strong>功能全面</strong></p><p>Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列等等场景，功能强大！</p><p>1.可以提高系统性能，减少延迟。<br>2.减轻数据库压力。<br>3.提高并发处理能力。<br>4.分布式系统支持，可以提供跨多个系统的的数据共享。<br>5.拥有灵活的缓存策略。</p><h2 id="三种常见的缓存读写策略"><a href="#三种常见的缓存读写策略" class="headerlink" title="三种常见的缓存读写策略"></a>三种常见的缓存读写策略</h2><h3 id="1-Cache-Aside-Pattern-旁路缓存策略"><a href="#1-Cache-Aside-Pattern-旁路缓存策略" class="headerlink" title="1.Cache Aside Pattern(旁路缓存策略)"></a>1.Cache Aside Pattern(旁路缓存策略)</h3><p>旁路缓存模式比较适合读请求比较多的场景，这种缓存策略需要服务端同时维护缓存和数据库，并且是以数据库的数据为准。这种策略的缓存读写步骤分别为：</p><p><strong>写：</strong>1.先更新数据库 2.数据库更新成功，再直接删除缓存<img src="../images/image-20240829194753712.png" alt="image-20240829194753712" style="zoom:80%;" /></p><p><strong>读：</strong>1.从缓存中读取数据 2.如果缓存中不存在，从数据库中读取 3.数据库中拿到数据后，先更新缓存中的数据，再返回数据<img src="/../images/image-20240829194812099.png" alt="image-20240829194812099"></p><h4 id="为什么删除cache，而不是更新cache？"><a href="#为什么删除cache，而不是更新cache？" class="headerlink" title="为什么删除cache，而不是更新cache？"></a>为什么删除cache，而不是更新cache？</h4><p>会对服务端的资源造成浪费，更新cache的话一般要经过一些计算得到，如果要频繁更新数据库里的数据的话，就要频繁更新cache中的数据，而cache中的数据可能都没被访问过就要更新，会造成大量的资源浪费。直接删除cache的话，一般不需要进行计算，直接删除即可。</p><h4 id="在写数据的过程中，可以先删除-cache-，后更新-db-么？"><a href="#在写数据的过程中，可以先删除-cache-，后更新-db-么？" class="headerlink" title="在写数据的过程中，可以先删除 cache ，后更新 db 么？"></a><strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong></h4><p>不行，因为这样可能会造成数据库与缓存中的数据不一致问题。</p><p>比如，请求1删除了缓存，但还没更新数据库中数据，此时请求2来了，因为缓存中没有数据，直接从数据库查询得到数据，这个数据就是旧的数据。</p><h4 id="在写数据的过程中，先更新-db，后删除-cache-就可以了吗？"><a href="#在写数据的过程中，先更新-db，后删除-cache-就可以了吗？" class="headerlink" title="在写数据的过程中，先更新 db，后删除 cache 就可以了吗？"></a>在写数据的过程中，先更新 db，后删除 cache 就可以了吗？</h4><p>理论来说，还是会造成缓存不一致的问题，但操作缓存的速度比操作数据库的速度快很多，出现不一致的概率就很小了。</p><h4 id="这种策略有什么缺点？"><a href="#这种策略有什么缺点？" class="headerlink" title="这种策略有什么缺点？"></a>这种策略有什么缺点？</h4><p>这种缓存策略有几个大的缺陷：</p><ol><li>首次请求时，cache中是没有数据的，需要访问数据库。</li></ol><p>解决办法：提前缓存热点数据。</p><ol><li>当有大量的写请求的时候，会频繁删除缓存中的数据，会影响缓存的命中率，影响系统的可用性。</li></ol><h3 id="2-Read-Write-Through-Pattern-读写穿透"><a href="#2-Read-Write-Through-Pattern-读写穿透" class="headerlink" title="2.Read&#x2F;Write Through Pattern(读写穿透)"></a>2.Read&#x2F;Write Through Pattern(读写穿透)</h3><p>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p><p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。</p><p><strong>写：</strong></p><ul><li>先查 cache，cache 中不存在，直接更新 db。</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li></ul><img src="../images/image-20240829194827697.png" alt="image-20240829194827697" style="zoom:80%;" /><p><strong>读：</strong></p><ul><li>从 cache 中读取数据，读取到就直接返回 。</li><li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。<img src="../images/image-20240829194853613.png" alt="image-20240829194853613" style="zoom:80%;" /></li></ul><h3 id="3-Write-Behind-Pattern-异步缓存写入"><a href="#3-Write-Behind-Pattern-异步缓存写入" class="headerlink" title="3.Write Behind Pattern(异步缓存写入)"></a>3.Write Behind Pattern(异步缓存写入)</h3><p>这种模式和读写穿透模式很像，都是有缓存服务来负责缓存和数据库的读写的。</p><p>异步缓存写入，它在更新缓存时，不会立马更新数据库，而是异步批量进行更新数据库。这种方式对数据的一致性带来了更大的挑战，比如还没进行异步批量更新数据库时，cache缓存宕机了，数据就丢失了。</p><p>这种模式下，数据库的写性能非常高，非常适合数据经常变化，但对数据的一致性没那么高要求的场景。</p><h2 id="redis除了做缓存，还可以做什么？"><a href="#redis除了做缓存，还可以做什么？" class="headerlink" title="redis除了做缓存，还可以做什么？"></a>redis除了做缓存，还可以做什么？</h2><p><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</p><p><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。如果不想自己写 Lua 脚本的话，也可以直接利用 Redisson 中的 <code>RRateLimiter</code> 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</p><p><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</p><p><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</p><p><strong>分布式 Session</strong> ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</p><p><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。</p><h2 id="redis的五种基本数据类型："><a href="#redis的五种基本数据类型：" class="headerlink" title="redis的五种基本数据类型："></a>redis的五种基本数据类型：</h2><h3 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h3><p>可以用来存储任何类型的数据。</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>1.计数器：INCR</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SET number 1</span><br><span class="line">OK</span><br><span class="line">INCR number <span class="comment"># 将 key 中储存的数字值增一</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">GET number</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">DECR number <span class="comment"># 将 key 中储存的数字值减一</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">GET number</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.缓存 Session、Token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)</p><p>3.分布式锁：利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁</p><h3 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h3><p>Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作</p><p><strong>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>实现队列</strong></p><p><strong>通过 <code>RPUSH/RPOP</code>或者<code>LPUSH/LPOP</code> 实现栈</strong></p><p><img src="/../images/image-20240829194912692.png" alt="image-20240829194912692"></p><p><strong>通过 <code>LRANGE</code> 查看对应下标范围的列表元素</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RPUSH myList value1 value2 value3</span><br><span class="line">(integer) 3</span><br><span class="line">LRANGE myList 0 1</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">LRANGE myList 0 -1</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">3) &quot;value3&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code>LRANGE</code> 命令，你可以基于 List 实现分页查询，性能非常高！</p><p><strong>通过 <code>LLEN</code> 查看链表长度</strong>：</p><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><p>获取最新文章、最新动态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH`、`LRANGE</span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash:"></a>Hash:</h3><p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，可以直接修改这个对象中的某些字段的值。</p><p>它类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p><img src="../images/image-20240829194928980.png" alt="image-20240829194928980" style="zoom:80%;" /><h4 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h4><p><strong>对象数据存储场景</strong>：</p><p>用户信息、商品信息、文章信息、购物车信息。</p><p><code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）</p><h3 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h3><p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code>。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p><p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p><img src="../images/image-20240829194948884.png" alt="image-20240829194948884" style="zoom:80%;" /><h4 id="应用场景：-3"><a href="#应用场景：-3" class="headerlink" title="应用场景："></a>应用场景：</h4><p>1.<strong>需要存放的数据不能重复的场景</strong>：</p><p>网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</p><ul><li>相关命令：<code>SCARD</code>（获取集合数量） 。</li></ul><p>2.<strong>需要获取多个数据源交集、并集和差集的场景</strong>：</p><p>共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。</p><p>3.<strong>需要随机获取数据源中的元素的场景</strong>：</p><p>抽奖系统、随机点名等场景。</p><p><code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）</p><h3 id="Sorted-Set："><a href="#Sorted-Set：" class="headerlink" title="Sorted Set："></a>Sorted Set：</h3><p>Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。</p><h4 id="应用场景：-4"><a href="#应用场景：-4" class="headerlink" title="应用场景："></a>应用场景：</h4><p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p><p>各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p><p><code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><table><thead><tr><th><strong>数据类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>String</td><td>一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</td></tr><tr><td>List</td><td>Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</td></tr><tr><td>Hash</td><td>一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</td></tr><tr><td>Set</td><td>无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</td></tr><tr><td>Zset</td><td>和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</td></tr></tbody></table><h2 id="Redis的持久化机制？"><a href="#Redis的持久化机制？" class="headerlink" title="Redis的持久化机制？"></a>Redis的持久化机制？</h2><p>使用缓存时需要对内存中的数据进行持久化，也就是把内存中的数据写入到磁盘里。大部分原因是为了重启应用后进行数据恢复以及进行数据同步的时候会用到持久化机制。</p><p>redis有三种持久化机制的方法：</p><ul><li>追加文件的方式(AOF)</li><li>拍摄快照的方式(RDB)</li><li>AOF + RDB 的混合方式(在redis4.0时才加入)</li></ul><h3 id="那么是什么RDB持久化？"><a href="#那么是什么RDB持久化？" class="headerlink" title="那么是什么RDB持久化？"></a>那么是什么RDB持久化？</h3><p>redis可以通过<strong>创建快照</strong>的方式来获得存储在内存中的数据的<strong>某个时间节点</strong>的副本。创建快照后，可以对快照进行备份，传输到不同的服务器，可以在不同的服务器上得到相同的数据；还可以将快照保存到本地，进行数据恢复时会用到。</p><p>快照持久化是 Redis 默认采用的持久化方式。</p><h3 id="Redis创建快照时会阻塞主线程吗？"><a href="#Redis创建快照时会阻塞主线程吗？" class="headerlink" title="Redis创建快照时会阻塞主线程吗？"></a>Redis创建快照时会阻塞主线程吗？</h3><p>redis提供了两个生成快照的命令，分别是：</p><p>save：这个命令会同步保存操作，会阻塞主线程的执行。</p><p>bgsave：这个命令会创建出一个子进程来进行快照文件的创建，不会影响到主线程的执行。redis中默认采用bgsave命令来创建快照。</p><h3 id="AOF持久化："><a href="#AOF持久化：" class="headerlink" title="AOF持久化："></a>AOF持久化：</h3><p>与快照相比，AOF持久化的实时性更好，默认情况下Redis没有开启AOF(Redis6.0之后默认是开启的)，可以通过appendonly参数来进行设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>开启AOF持久化机制后，redis每执行一个写操作都会把该操作写道AOF缓存区里，在把缓冲区中的数据写到AOF文件内，最后通过持久化方式的配置文件把系统内核缓冲区中的数据同步到磁盘上。</p><p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。</p><h3 id="AOF的基本工作流程："><a href="#AOF的基本工作流程：" class="headerlink" title="AOF的基本工作流程："></a>AOF的基本工作流程：</h3><ol><li>命令追加：追加redis中的写操作命令到AOF缓冲区里。</li><li>文件写入：将AOF缓冲区中的数据添加到一个AOF文件内，这个文件在系统内核缓冲区，此时还没有同步到磁盘里。</li><li>文件同步：将系统内核缓冲区中的AOF文件同步到磁盘上。</li><li>文件重写：当AOF文件过大时，会重写AOF文件。</li><li>重启加载文件: 当redis重启时,会加载这个AOF文件进行数据恢复。</li></ol><img src="../images/image-20240829195009366.png" alt="image-20240829195009366" style="zoom:80%;" /><h3 id="AOF的刷盘策略有哪些？"><a href="#AOF的刷盘策略有哪些？" class="headerlink" title="AOF的刷盘策略有哪些？"></a>AOF的刷盘策略有哪些？</h3><p>在redis中的AOF的刷盘策略有三种：</p><p><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</p><p><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</p><p><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</p><p>可以看出：<strong>这 3 种持久化方式的主要区别在于 <code>fsync</code> 同步 AOF 文件的时机（刷盘）</strong>。</p><p>为了兼顾数据和写入性能，可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><h3 id="AOF为什么在执行完命令之后进行日志记录？"><a href="#AOF为什么在执行完命令之后进行日志记录？" class="headerlink" title="AOF为什么在执行完命令之后进行日志记录？"></a>AOF为什么在执行完命令之后进行日志记录？</h3><p>Mysql通常是在执行命令之前就记录日志(方便故障恢复)，redis的AOF是在命令执行结束后进行记录日志。</p><img src="../images/image-20240829195026751.png" alt="image-20240829195026751" style="zoom:80%;" /><ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p><ul><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）；</li></ul><h3 id="如何旋转RDB和AOF？"><a href="#如何旋转RDB和AOF？" class="headerlink" title="如何旋转RDB和AOF？"></a>如何旋转RDB和AOF？</h3><p><strong>RDB 比 AOF 优秀的地方</strong>：</p><ul><li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li><li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li></ul><p><strong>AOF 比 RDB 优秀的地方</strong>：</p><ul><li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li><li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li><li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li></ul><p><strong>综上：</strong></p><ul><li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li><li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li><li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li></ul><h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器?"></a>什么是布隆过滤器?</h2><p>布隆过滤器是一种由数组和一系列随机映射函数所组成的数据结构，它的数组中只能存储0或1。相比我们常用的list、map、set等数据结构，它所用的空间更少和效率更高，但缺点是返回的结果具有概率性，不准确。</p><p>布隆过滤器会使用一个较大的bit数组来保存数据，数组中每个元素只占用1bit，并且每个元素只能是0或1。</p><h2 id="布隆过滤器的原理介绍："><a href="#布隆过滤器的原理介绍：" class="headerlink" title="布隆过滤器的原理介绍："></a>布隆过滤器的原理介绍：</h2><p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>Bloom Filter 的简单原理图如下：<img src="/../images/image-20240829195048881.png" alt="image-20240829195048881"></p><p>如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。</p><p>如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p><p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p><p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在</strong></p><h2 id="布隆过滤器的使用场景："><a href="#布隆过滤器的使用场景：" class="headerlink" title="布隆过滤器的使用场景："></a>布隆过滤器的使用场景：</h2><ul><li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，上亿）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤（判断一个邮件地址是否在垃圾邮件列表中）、黑名单功能（判断一个 IP 地址或手机号码是否在黑名单中）等等。</li><li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重、对巨量的 QQ 号&#x2F;订单号去重。</li></ul><h3 id="guava的布隆过滤器实现："><a href="#guava的布隆过滤器实现：" class="headerlink" title="guava的布隆过滤器实现："></a>guava的布隆过滤器实现：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;28.0-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。</strong></p><h3 id="Redis-中的布隆过滤器"><a href="#Redis-中的布隆过滤器" class="headerlink" title="Redis 中的布隆过滤器"></a><a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter.html#redis-%E4%B8%AD%E7%9A%84%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">Redis 中的布隆过滤器</a></h3><h2 id="基于redis实现分布式锁："><a href="#基于redis实现分布式锁：" class="headerlink" title="基于redis实现分布式锁："></a>基于redis实现分布式锁：</h2><h3 id="基于redis实现一个最简单的分布式锁："><a href="#基于redis实现一个最简单的分布式锁：" class="headerlink" title="基于redis实现一个最简单的分布式锁："></a>基于redis实现一个最简单的分布式锁：</h3><p>不论是本地锁还是分布式锁，<strong>核心都在于“互斥”</strong>。</p><p>我们使用setnx命令来帮助实现分布锁。<code>SETNX</code> 即 <strong>SET if Not Exists</strong> (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SETNX lockKey uniqueValue</span><br><span class="line">(integer) 1</span><br><span class="line">SETNX lockKey uniqueValue</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEL lockKey</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>为了防止误删操作，可以使用lua脚本来通过判断key的value唯一值进行删除锁。选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放</span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/" alt="Redis 实现简易分布式锁"></p><p>这是一种最简易的 Redis 分布式锁实现方式，实现简单，性能高效。不过，这种方式可能存在一些问题。比如释放锁时应用突然挂掉了，就导致锁无法释放，造成共享资源无法被其他线程访问。</p><p>为了避免锁无法被释放，我们可以<strong>给这个 key（也就是锁） 设置一个过期时间</strong>。</p><p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p><h3 id="锁续期："><a href="#锁续期：" class="headerlink" title="锁续期："></a>锁续期：</h3><p>可以使用Redisson自动实现锁的续期。  </p><p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多功能，其中就包括多种分布式锁的实现。Redisson 中的分布式锁自带自动续期机制，使用起来很简单，原理也比较简单，其中提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p><p><img src="/../images/image-20240829195112739.png" alt="image-20240829195112739"></p><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p><p>如果使用 Redis 来实现分布式锁的话，推荐直接基于 Redisson 来做。</p><h3 id="可重入锁？"><a href="#可重入锁？" class="headerlink" title="可重入锁？"></a>可重入锁？</h3><p>可重入锁（Reentrant Lock）是一种特殊的锁机制，允许一个已经拥有锁的线程再次获取同一把锁而不产生死锁。简单来说，可重入锁允许一个线程多次获取同一把锁，而不会因为自身获取锁而导致阻塞</p><p>Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p><p><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。</strong></p><p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p><p>实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</p><h2 id="redis实现点赞？"><a href="#redis实现点赞？" class="headerlink" title="redis实现点赞？"></a>redis实现点赞？</h2><p><strong>方案一：使用哈希表（Hash）</strong></p><p>哈希表是一种键值对结构，可以用来存储点赞用户的信息。每个点赞用户都有一个唯一的 ID，可以将这些 ID 存储在哈希表中。</p><p><strong>数据结构：</strong></p><p>点赞用户的哈希表</p><ul><li>键：<code>likes:post_id</code>，其中 <code>post_id</code> 是帖子的唯一标识。</li><li>值：存储点赞用户 ID 的哈希表，键为用户 ID，值可以设置为 1 或任何其他值。</li></ul><p><strong>操作方法：</strong></p><p><strong>1.点赞:</strong></p><ul><li>使用 <code>HSET</code> 命令将用户 ID 添加到哈希表中。</li><li>例如，如果用户 ID 为 <code>user123</code> 对帖子 <code>post456</code> 点赞，可以使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET likes:post456 user123 1</span><br></pre></td></tr></table></figure><p><strong>2.取消点赞:</strong></p><ul><li>使用 <code>HDEL</code> 命令从哈希表中删除用户 ID。</li><li>例如，如果用户 ID 为 <code>user123</code> 取消对帖子 <code>post456</code> 的点赞，可以使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL likes:post456 user123</span><br></pre></td></tr></table></figure><p><strong>3.查询点赞数</strong>：</p><ul><li>使用 <code>HLEN</code> 命令获取哈希表中的键值对数量。</li><li>例如，查询帖子 <code>post456</code> 的点赞数，可以使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN likes:post456</span><br></pre></td></tr></table></figure><p><strong>4.查询是否点赞:</strong></p><ul><li>使用 <code>HEXISTS</code> 命令检查用户 ID 是否存在于哈希表中。</li><li>例如，查询用户 ID <code>user123</code> 是否对帖子 <code>post456</code> 点赞，可以使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS likes:post456 user123</span><br></pre></td></tr></table></figure><p><strong>5.获取点赞用户列表:</strong></p><ul><li>使用 <code>HGETALL</code> 命令获取哈希表中的所有键值对。</li><li>例如，获取帖子 <code>post456</code> 的所有点赞用户，可以使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGETALL likes:post456</span><br></pre></td></tr></table></figure><p><strong>方案二：使用集合（Set）</strong></p><p>集合是一种不允许重复成员的数据结构，可以用来存储点赞用户的 ID。</p><p><strong>数据结构</strong></p><p>点赞用户的集合：</p><ul><li>键：<code>likes:post_id</code>，其中 <code>post_id</code> 是帖子的唯一标识。</li><li>值：存储点赞用户 ID 的集合。</li></ul><p><strong>1.点赞:</strong></p><ul><li>使用 <code>SADD</code> 命令将用户 ID 添加到集合中。</li><li>例如，如果用户 ID 为 <code>user123</code> 对帖子 <code>post456</code> 点赞，可以使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD likes:post456 user123</span><br></pre></td></tr></table></figure><p><strong>2.取消点赞:</strong></p><ul><li>使用 <code>SREM</code> 命令从集合中删除用户 ID。</li><li>例如，如果用户 ID 为 <code>user123</code> 取消对帖子 <code>post456</code> 的点赞，可以使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM likes:post456 user123</span><br></pre></td></tr></table></figure><p><strong>3.查询点赞数:</strong></p><ul><li>使用 <code>SCARD</code> 命令获取集合中的成员数量。</li><li>例如，查询帖子 <code>post456</code> 的点赞数，可以使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD likes:post456</span><br></pre></td></tr></table></figure><p><strong>4.查询是否点赞:</strong></p><ul><li>使用 <code>SISMEMBER</code> 命令检查用户 ID 是否存在于集合中。</li><li>例如，查询用户 ID <code>user123</code> 是否对帖子 <code>post456</code> 点赞，可以使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER likes:post456 user123</span><br></pre></td></tr></table></figure><p><strong>5.获取点赞用户列表:</strong></p><ul><li>使用 <code>SMEMBERS</code> 命令获取集合中的所有成员。</li><li>例如，获取帖子 <code>post456</code> 的所有点赞用户，可以使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS likes:post456</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;redis为什么这么快？&quot;&gt;&lt;a href=&quot;#redis为什么这么快？&quot; class=&quot;headerlink&quot; title=&quot;redis为什么这么快？&quot;&gt;&lt;/a&gt;redis为什么这么快？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Redis 基于内存，内存的访问速度比磁盘快很多</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mysql数据库</title>
    <link href="http://example.com/2024/08/29/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2024/08/29/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2024-08-29T11:23:54.053Z</published>
    <updated>2024-08-29T11:47:29.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-外键是什么？"><a href="#1-外键是什么？" class="headerlink" title="1.外键是什么？"></a>1.外键是什么？</h2><p>外键是一种用来与其他表建立联系的字段的名称，它是另一张表的主键，外键可以重复，可以有空值。并且一张表里可以有多个外键。</p><h2 id="2-为什么有的公司会禁止使用外键？"><a href="#2-为什么有的公司会禁止使用外键？" class="headerlink" title="2.为什么有的公司会禁止使用外键？"></a>2.为什么有的公司会禁止使用外键？</h2><ol><li>外键更适用于单机系统和低并发场景，不适合在分布式、高并发场景使用。</li><li>外键约束会导致级联更新或删除，级联更新可能会影响到其他表中的数据，造成数据不一致的问题。</li><li>在分布式系统中，在多个数据源中进行外键约束会难以实现。</li><li>在高并发场景下，外键约束会造成额外的系统消耗，因为在进行数据的插入和删除时，数据库会检查引用的完整性。</li><li>一般会在应用层进行逻辑控制。</li></ol><h2 id="3-什么是存储过程"><a href="#3-什么是存储过程" class="headerlink" title="3.什么是存储过程?"></a>3.什么是存储过程?</h2><p>我也没用过存储过程，我只知道它的一些概念和用法。</p><p>存储过程简单来说就是预先编写好许多sql语句，把这个sql语句集合存储在数据库服务器上，之后可以通过指定的名称进行调用执行。</p><p><strong>存储过程的优点有：</strong></p><ol><li>具备可重用性：存储过程是把一组sql语句封装在一起，作为一个执行单元，一旦创建，存储过程就可以在不同的程序中去调用执行。</li><li>灵活性：存储过程可以传递参数，也可以包含控制流语句，使其更加灵活。</li><li>提高性能：因为存储过程实在数据库服务中的，减少了客户端和服务器之间的数据传输，减少了网络延迟，提高了数据的处理速度。</li><li>减少了复杂性：因为存储过程是一组sql语句的集合，所以可以包含许多复杂的SQL语句，减少了复杂性。</li></ol><h2 id="4-drop、delete-与-truncate-区别？"><a href="#4-drop、delete-与-truncate-区别？" class="headerlink" title="4.drop、delete 与 truncate 区别？"></a>4.drop、delete 与 truncate 区别？</h2><ol><li><code>drop</code> 语句指<code>drop tablename</code>，表示删除表中的数据和表的结构。</li><li><code>truncate</code>语句指<code>truncate tablename</code>，表示清空表中的数据，不会影响表的结构，并且会把自增值重置和索引恢复到初始大小。</li><li><code>delete</code>语句指<code>delete tablename where id = #&#123;id&#125;</code> 或 <code>delete tablename</code> ，前一种表示删除对应id的数据，不会影响表的结构。第二种指删除表中的所有的数据，不会影响表的结构。 </li><li><code>truncate</code> 和 <code>drop</code> 属于 DDL(数据定义语言)语句,<code>delete</code>表示数据库操作语句。</li></ol><h2 id="5-整数类型的-UNSIGNED-属性有什么用？"><a href="#5-整数类型的-UNSIGNED-属性有什么用？" class="headerlink" title="5.整数类型的 UNSIGNED 属性有什么用？"></a>5.整数类型的 UNSIGNED 属性有什么用？</h2><p>Mysql中的整数类型可以使用unsigned属性来修饰，表示无符号整数。使用过unsigned属性修饰的整数的取值范围会大一倍，因为它不需要存储负数。如tinyint 的范围时-128<del>127，如果用tinyint unsigned修饰，它的范围为0</del>255；</p><p>对于从 0 开始递增的 ID 列，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p><h2 id="6-CHAR和VARCHAR的区别？"><a href="#6-CHAR和VARCHAR的区别？" class="headerlink" title="6.CHAR和VARCHAR的区别？"></a>6.CHAR和VARCHAR的区别？</h2><p>主要区别在于：</p><ol><li>char是定长字符串，varchar是变长字符串。</li><li>char在存储时会在右边用空格填充以达到指定长度，检索时会去掉字符串，varchar会用1或2个字节来存储字符串的长度，进行检索时不会处理。</li><li>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</li></ol><h2 id="7-DECIMAL和FLOAT-DOUBLE的区别是什么？"><a href="#7-DECIMAL和FLOAT-DOUBLE的区别是什么？" class="headerlink" title="7.DECIMAL和FLOAT&#x2F;DOUBLE的区别是什么？"></a>7.DECIMAL和FLOAT&#x2F;DOUBLE的区别是什么？</h2><ol><li>decimal和float的区别主要在于：</li><li>decimal是定点小数，float是浮点数。</li><li>decimal可以存储精确的小数值，float只能存储近似的小数值。decimal类型与Java中的类BigDecimal相对应。</li></ol><h2 id="8-为什么-MySQL-不建议使用-NULL-作为列默认值"><a href="#8-为什么-MySQL-不建议使用-NULL-作为列默认值" class="headerlink" title="8.为什么 MySQL 不建议使用 NULL 作为列默认值"></a>8.为什么 MySQL 不建议使用 <code>NULL</code> 作为列默认值</h2><ol><li>数据一致性：使用null作为默认值时，可能会造成数据不一致的问题。因为我们不能判断这个null值时默认值还是被有意设置的。</li><li>查询变的复杂了一点：当字段设置默认值为null时，我们进行判断时，是使用is null或is not null 来判断的，而不是使用数学符合来判断的。</li><li>也会影响到索引的查询效率。</li><li>对于某些函数来说，会忽略掉null值，比如sum()、avg()，还有count()函数，如果是count(*)会统计所有的数据，如果传的是字段名，会忽略掉null值。</li><li>在进行连表查询时，null&#x3D;null会返回未知值，产生错误。</li><li>对于业务逻辑来说也会增加复杂性。</li></ol><h2 id="9-MyISAM和InnoDB有什么区别？"><a href="#9-MyISAM和InnoDB有什么区别？" class="headerlink" title="9.MyISAM和InnoDB有什么区别？"></a>9.MyISAM和InnoDB有什么区别？</h2><p><strong>1.是否支持行级锁</strong></p><p>MyISAM只支持表级锁，也就是说，它锁住的是一张表，在并发写的情况下，性能太差。而InnoDB支持表级锁和行级锁，默认是行级锁，在并发写的情况下，性能会好很多。</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现和定义了四个隔离级别，具有commit和rollback事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别，它是可以解决幻读问题发生的，（是基于 MVCC 和 Next-Key Lock来解决的）。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用InnoDB存储引擎在数据库异常崩溃后，数据库重新启动时会通过redolog来进行数据的恢复。</p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p><p><strong>6.性能有差别。</strong></p><p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</p><p><strong>7.数据缓存策略和机制实现不同。</strong></p><p>InnoDB 使用缓冲池（Buffer Pool）缓存数据页和索引页，MyISAM 使用键缓存（Key Cache）仅缓存索引页而不缓存数据页。</p><h2 id="10-索引是什么"><a href="#10-索引是什么" class="headerlink" title="10.索引是什么?"></a>10.索引是什么?</h2><p>索引是一种快速查找和检索数据的数据结构,其本质可以看出是一种排序好的数据结构。索引就相当于目录,当我们一个字时,我们只需要在目录中找到该字对应的页码,直接翻到该页码就找到了。</p><p>索引的实现有很多数据类型，常见的有B树、B+树和hash等等。</p><p>优点：</p><ol><li>创建索引可以大大减少数据检索数据量，提高数据的查询效率，减少磁盘I&#x2F;O次数。</li><li>通过创建唯一索引可以保证数据库表中的数据的唯一性。</li></ol><p>缺点：</p><ol><li>创建索引和维护索引需要消耗额外的时间，在进行数据的增删改时，如果数据有索引，需要动态的修改索引，降低sql执行效率。</li><li>索引需要物理文件存储，需要消耗一定的空间。</li></ol><h2 id="11-索引底层数据结构选型"><a href="#11-索引底层数据结构选型" class="headerlink" title="11.索引底层数据结构选型"></a>11.索引底层数据结构选型</h2><h3 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h3><p>hash表是key-value键值对集合，通过键(key)可以快速获取值(value)。原理是hash算法，通过hash算法可以快速计算出index，然后通过index可以快速获取值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = hashfunc(key)</span><br><span class="line">index = hash % array_size</span><br></pre></td></tr></table></figure><p>但是hash算法存在一个哈希冲突的问题，也就是说多个key得到同一个hash值。通常情况下使用链地址法来解决。链地址法指就是将哈希冲突的数据放到链表中。Java中的HashMap就是这样解决的。</p><p>为了减少 Hash 冲突的发生，一个好的哈希函数应该<strong>“均匀地”</strong>将数据分布在整个可能的哈希值集合中。MySQL 的 InnoDB 存储引擎不直接支持常规的哈希索引，但是，InnoDB 存储引擎中存在一种特殊的“自适应哈希索引”（Adaptive Hash Index），自适应哈希索引并不是传统意义上的纯哈希索引，而是结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的每个哈希桶实际上是一个小型的 B+Tree 结构。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。</p><p><strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong><br>因为hash索引不支持顺序查找和范围查找。</p><h3 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树(BST)"></a>二叉查找树(BST)</h3><p>二叉查找树是一种基于二叉树的数据结构。它的特点：</p><p>1.左子树的所有节点的值都小于根节点。</p><p>2.右子树的所有节点的值都大于根节点。</p><p>3.左右子树也分别是二叉查找树。</p><p>当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过 1 的时候，它的查找效率为O(logN)，当二叉查找树不平衡的时候，可能会退化成一个链表结构，它的查找效率为O(N)。<strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p><h3 id="AVL树-二叉平衡树"><a href="#AVL树-二叉平衡树" class="headerlink" title="AVL树(二叉平衡树)"></a>AVL树(二叉平衡树)</h3><p>AVL树的特点是保证任何节点的左右子树的高度不相差1，它的查找、插入和删除在最坏和平均的情况下时间复杂都是O(logN)。AVL树采用了自旋操作来保证平衡，主要有四种旋转操作:LL旋转、RR旋转、LR旋转和RL旋转。</p><p>由于AVL树需要频繁的进行自旋操作来保证平衡，因此会有较大的计算开销从而降低数据库的写操作性能。并且，AVL树的每个节点只能存储一个数据，每次进行磁盘I&#x2F;O读写时只能读取一个节点的数据，当查询的数据分布在多个节点上时，那么就需要进行多次磁盘I&#x2F;O。而磁盘I&#x2F;O是一个耗时的操作，所以我们在设计数据库时应该尽量减少磁盘I&#x2F;O的次数。所以在实际应用中，AVL树用的不多。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树()"></a>红黑树()</h3><p>红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：</p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL 节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从任意节点到它的叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p>与平衡二叉树相比，红黑树不需要保证严格的平衡，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作即可保持基本平衡状态。正是如此，红黑树的树可能会很深，查询效率可能会有所下降，因为树深了，就需要更多的磁盘I&#x2F;O，这也是Mysql没使用红黑树的原因。</p><p><strong>红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。</strong></p><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><p>B 树被称为 <strong>多路平衡查找树</strong>，而B+树是B树的变种。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ol><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他的节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一个指针指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li></ol><p>综上，B+树与 B 树相比，具备<strong>更少的 IO 次数</strong>、<strong>更稳定的查询效率</strong>和<strong>更适于范围查询</strong>这些优势。</p><p><strong>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。</strong>(下面的内容整理自《Java 工程师修炼之道》)</p><blockquote><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></blockquote><h2 id="12-索引类型"><a href="#12-索引类型" class="headerlink" title="12.索引类型"></a>12.索引类型</h2><p><strong>按索引的底层存储方式划分的话分为：</strong></p><p><strong>聚簇索引：</strong>聚簇索引是索引结构和数据文件存放在一起的，InnoDB中的主键索引就是聚簇索引。在 MySQL 中，InnoDB 存储引擎中的<code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引的每个非叶子节点存储索引的key，叶子节点存储索引的key和索引对应的数据。</p><p>优点：<strong>查询速度非常快</strong>，特别对于<strong>范围查找和排序查找</strong>来说。</p><p><strong>缺点：因为底层是一个B+树结构，它存储了索引对应的key和数据，占用了磁盘空间，且如果对聚簇索引的字段进行修改、删除操作时，会造成动态修改这个索引结构，对于系统性能来说这是个不小的开销。</strong></p><p><strong>非聚簇索引：</strong>非聚簇索引是指索引结构和数据分开存放，所有的二级索引都是非聚簇索引。MySQL 的 MyISAM 存储引擎，不管主键还是非主键，使用的都是非聚簇索引。</p><p>非聚簇索引的叶子节点并不一定存放数据的指针，因为在InnoDB中，二级索引的叶子节点就存放的是主键key，然后再根据主键回表查数据。</p><p><strong>非聚簇索引不一定要回表查询。比如查询设置了覆盖索引的字段的值的时候就不需要进行回表查询。</strong></p><p><strong>按应用维度划分的话分为：</strong></p><ul><li>主键索引：目的是加速查询，列的值必须唯一且不能为null，一张表中只能有一个主键索引。如果没有显式指定主键索引，那么InnoDB存储引擎会自动寻找表中的唯一索引且该字段不能为null值，作为主键索引，如果表中没有唯一索引，那么InnoDB存储引擎会自动创建一个6比特的自增主键。</li><li>唯一索引：主要目的是为了表示该字段的值是唯一的，可以为null，并且一个表中可以有多个唯一索引。</li><li>联合索引：多个字段一起组成的索引，专门用于组合查询。</li><li>覆盖索引：一个索引中就可以包含所有需要查询的字段的值，可以大大加快查询的效率。<strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></li><li>普通索引：目的就是加快查询速度，一张表中可以有多个。</li><li>全文索引：全文索引一般只适用于char、varchar、text类型的字段，目的是为了在长文本中找到所需的关键字。在Mysql5.6之后，InnoDB存储引擎才支持。但我没在Mysql中用过。这种全文检索的话，一般使用ElasticSearch搜索引擎。</li></ul><h3 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h3><p>再InnoDB存储引擎中，非主键索引的叶子节点存储的是主键索引的值，当使用非主键索引进行查询时，数据库会先找到该主键的值，再根据这个主键值去定位和检索完整的数据，这个过程就叫做回表。如果查询的字段刚好是索引的值，那么就无需回表，直接查询到数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，那么直接根据这个索引就可以查到数据，也无需回表。</span><br></pre></td></tr></table></figure><h3 id="联合索引：多个字段一起组成的索引"><a href="#联合索引：多个字段一起组成的索引" class="headerlink" title="联合索引：多个字段一起组成的索引"></a>联合索引：多个字段一起组成的索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure><p>联合索引是按创建联合索引时的从做到右顺序进行排序的，比如说，我创建了一个联合索引，它的从左到右的顺序为product_no、name，当它底层使用B+树进行排序时，会按照从左到右的顺序排序，先按product_no排序，然后product_no相同的情况下，按照name排序。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行匹配时，如果不遵循最左匹配原则，联合索引就会失效。</p><p>比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以使用联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p><strong>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</strong></p><p>如果查询条件是以下这几种，因为不符合最左匹配原则，所以无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>上面这些查询条件之所以会失效，是因为(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p><p><img src="/../images/image-20240829194329331.png" alt="image-20240829194329331"></p><p>可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行 where b &#x3D; 2 这种查询条件没有办法利用联合索引的，<strong>利用索引的前提是索引里的 key 是有序的</strong>。</p><p>只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行 where a &#x3D; 2 and b &#x3D; 7 这种查询条件时， a 和 b 字段能用到联合索引的，也就是联合索引生效了。</p><p><strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。</strong></p><h2 id="13-何为事务？"><a href="#13-何为事务？" class="headerlink" title="13.何为事务？"></a>13.何为事务？</h2><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><h3 id="何为数据库事务？"><a href="#何为数据库事务？" class="headerlink" title="何为数据库事务？"></a>何为数据库事务？</h3><p>数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> </p><p>关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><strong>原子性</strong>（<code>Atomicity</code>）：事务的最小执行单位，不再进行分割，原子性保证了数据库中的这些操作要么都执行成功，要么都执行失败。</p><p><strong>一致性</strong>（<code>Consistency</code>）：在执行事务的前后，数据都要保证一致。</p><p><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不能被其他事务所干扰，每个事务是相互独立的。</p><p><strong>持久性</strong>（<code>Durability</code>）：一个事务提交后，它对数据库的数据的修改是持久的，就是数据库发生宕机，也不会对其有任何影响。</p><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p><h3 id="并发事务带来了哪些问题？"><a href="#并发事务带来了哪些问题？" class="headerlink" title="并发事务带来了哪些问题？"></a>并发事务带来了哪些问题？</h3><p>多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。</p><h4 id="脏读："><a href="#脏读：" class="headerlink" title="脏读："></a>脏读：</h4><p>一个事务对数据进行了修改，这个修改对其他事务是可见的，在还没有提交这个事务时，其他事务来对这个数据等进行读取，此时前一个事务进行回滚操作，其他事务读取到的数据就是一个脏数据，这就是脏读。</p><h4 id="修改丢失："><a href="#修改丢失：" class="headerlink" title="修改丢失："></a>修改丢失：</h4><p>在一个事务读取一个数据时，另一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个数据也修改了这个数据。这样第一个事务的修改就被丢失了，这就是修改丢失。</p><h4 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h4><p>在一个事务中多次读取同一个数据时，另一个事务对该数据进行修改，那么在第一个事务多次进行读取该数据时，由于第二个事务的修改导致第一个事务读取到的数据不一样，这就发生了在一个事务内读取到不同的数据，这就是不可重复读。</p><h4 id="幻读："><a href="#幻读：" class="headerlink" title="幻读："></a>幻读：</h4><p>在一个事务进行多次读取数据时，另一个事务此时插入了一些数据，导致第一个事务读取到了原本不存在的数据，这就是幻读。</p><h4 id="不可重复读和幻读的区别？"><a href="#不可重复读和幻读的区别？" class="headerlink" title="不可重复读和幻读的区别？"></a>不可重复读和幻读的区别？</h4><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h2 id="14-并发事务的控制方式有哪些？"><a href="#14-并发事务的控制方式有哪些？" class="headerlink" title="14.并发事务的控制方式有哪些？"></a>14.并发事务的控制方式有哪些？</h2><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p><p><strong>锁</strong> 控制方式下会通过加锁来显式控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><p><strong>共享锁：</strong>又称为读锁，事务在读取数据时，会获取共享锁。当事务获取共享锁后，其他事务仍然可以获取到该数据，但不能对其进行修改。</p><p><strong>排他锁：</strong>又称为写锁或者独占锁，事务在修改数据时会获取排他锁。当事务获取了排他锁后，不允许其他事务对该数据进行任何读取或修改操作。</p><p><strong>共享锁</strong>允许多个事务同时读取数据，但阻止其他事务对数据进行写操作。</p><p><strong>排他锁</strong>阻止所有其他事务读取或写入数据，确保数据在修改时不会被其他事务干扰</p><p>读写锁可以做到读读并行，但不能做到读写并行、写写并行。另外，根据锁粒度不同又分为表级锁和行级锁。InnoDB存储引擎既支持表级锁，也支持行级锁，并且InnoDB默认是行级锁。行级锁的锁粒度更小，仅对相关联的记录加锁，所以对于并发写入操作来说，InnoDB的性能更好。不论表级锁还是行级锁，都支持共享锁和排他锁。</p><p><strong>MVCC</strong> 是多版本并发控制，即对一份数据存储多个不同版本，通过事务的可见性来保证事务可以看到自己应该看到的数据版本。<strong>会有一个全局的版本分配器来为每一行数据分配一个唯一的版本号。</strong></p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul><h2 id="15-SQL标准定义了哪些隔离级别？"><a href="#15-SQL标准定义了哪些隔离级别？" class="headerlink" title="15.SQL标准定义了哪些隔离级别？"></a>15.SQL标准定义了哪些隔离级别？</h2><p>**READ-UNCOMMITTED(读取未提交)**：最低的隔离级别，允许读取到尚未提交的数据，可能会导致脏读、不可重复读和幻读的问题。</p><p>**READ-COMMITTED(读取已提交)**：只能读取到事务已经提交的数据，解决了脏读的问题，但可能会有不可重复读和幻读的问题。</p><p>**REPEATABLE-READ(可重复读)**：对同一数据的多次读取结果都是一致的，除非数据是被本身事务所修改的，解决了脏读和不可重复读的问题，但还有幻读的问题。</p><p><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p><h2 id="16-MySQL-的隔离级别是基于锁实现的吗？"><a href="#16-MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="16.MySQL 的隔离级别是基于锁实现的吗？"></a>16.MySQL 的隔离级别是基于锁实现的吗？</h2><p>MySQL 的隔离级别基于<strong>锁</strong>和 <strong>MVCC 机制</strong>共同实现的。</p><p><strong>SERIALIZABLE</strong> 隔离级别是通过锁来实现的，<strong>READ-COMMITTED 和 REPEATABLE-READ 隔离级别</strong>是基于 <strong>MVCC</strong> 实现的。不过， <strong>SERIALIZABLE</strong> 之外的其他隔离级别可能也需要<strong>用到锁机制</strong>，就比如 <strong>REPEATABLE-READ</strong> 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h2 id="17-Mysql的性能优化"><a href="#17-Mysql的性能优化" class="headerlink" title="17.Mysql的性能优化"></a>17.Mysql的性能优化</h2><h3 id="能用-MySQL-直接存储文件（比如图片）吗？"><a href="#能用-MySQL-直接存储文件（比如图片）吗？" class="headerlink" title="能用 MySQL 直接存储文件（比如图片）吗？"></a>能用 MySQL 直接存储文件（比如图片）吗？</h3><p>可以是可以，直接存储文件对应的二进制数据即可。不过，一般不会直接存储文件到数据库中，会严重影响数据库性能，消耗过多存储空间。</p><p>可以选择使用云服务厂商提供的开箱即用的文件存储服务。<strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p><h3 id="Mysql如何存储IP地址？"><a href="#Mysql如何存储IP地址？" class="headerlink" title="Mysql如何存储IP地址？"></a>Mysql如何存储IP地址？</h3><p>可以将 IP 地址转换成整形数据存储到数据库。</p><p>MySQL 提供了两个方法来处理 ip 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INET_ATON()//把ip地址转换成整型数据(4~8位)</span><br><span class="line">INET_NTOA()//把整型数据转换成IP地址</span><br></pre></td></tr></table></figure><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可.</p><h2 id="18-Mysql的三大日志："><a href="#18-Mysql的三大日志：" class="headerlink" title="18.Mysql的三大日志："></a>18.Mysql的三大日志：</h2><p>MySQL 日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属<strong>二进制日志 binlog（归档日志）和事务日志 redo log（重做日志）和 undo log（回滚日志）</strong>。</p><h3 id="redolog："><a href="#redolog：" class="headerlink" title="redolog："></a>redolog：</h3><p>redolog(重做日志)，是InnoDB存储引擎所特有的，它让MySQL拥有了崩溃恢复的能力。</p><p>比如当Mysql宕机或挂了，重启时，InnoDB存储引擎会使用redolog恢复数据，保证数据的完整性与持久性。</p><p><img src="/../images/image-20240829194357373.png" alt="image-20240829194357373"></p><p>Mysql中的数据是以页为单位的，你查询一条记录，就会从硬盘里把一页数据加载出来，加载出来的数据叫做数据页，会被放入Buffer Pool里面。后续的查询都是先从Buffer Pool 中查找，如果没有命中缓存，再去加载硬盘查询，减少了硬盘I&#x2F;O的开销，提升性能。</p><p>更新表数据的时候也是如此，发现Buffer Pool 里存在数据就直接在Buffer Pool 中更新，然后把”在某个数据页上做了什么修改” 记录到redolog重做日志缓存里去，接着会刷盘到redolog文件里。</p><p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p><p><img src="/../images/image-20240829194417617.png" alt="image-20240829194417617"></p><h3 id="刷盘时机："><a href="#刷盘时机：" class="headerlink" title="刷盘时机："></a>刷盘时机：</h3><ol><li>一般当事务提交的时候就会把缓存中的修改信息刷新到磁盘里。</li><li>当redolog重做日志缓存容量不足时，就会把这些信息刷新到磁盘里。</li><li>InnoDB 使用一个事务日志缓冲区（transaction log buffer）来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘。</li><li>InnoDB 定期会执行检查点操作，将内存中的已修改但尚未写入磁盘的数据刷新到磁盘上，并且会将相应的重做日志一同刷新，以确保数据的一致性。</li><li>InnoDB 有一个一个后台线程，负责周期性（每隔 1 秒）地将脏页（已修改但尚未写入磁盘的数据页）刷新到磁盘，并将相关的重做日志一同刷新。</li><li>MySQL 正常关闭的时候，redo log 都会刷入到磁盘里去。</li></ol><p><strong>总之，InnoDB 在多种情况下会刷新重做日志，以保证数据的持久性和一致性。</strong></p><p>这里有个参数可以控制在事务提交后的刷盘策略，这个参数是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit</span><br></pre></td></tr></table></figure><ol><li>默认值位1，表示每次事务提交都会进行刷盘操作，只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。</li><li>当innodb_flush_log_at_trx_commit的值位0时，表示每次事务提交都不会进行刷盘操作。</li><li>值为2时，表示每次事务提交时都把数据写入page cache（文件系统缓存）里。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。</li></ol><p>另外，InnoDB 存储引擎有一个<strong>后台线程</strong>，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <strong><code>fsync</code></strong> 刷盘。</p><p><img src="/../images/image-20240829194434815.png" alt="image-20240829194434815"></p><p><strong>一个没有提交事务的 redo log 记录，也可能会刷盘。</strong></p><p>因为在事务执行过程 redo log 记录是会写入<code>redo log buffer</code> 中，这些 redo log 记录会被后台线程刷盘。</p><p><img src="/../images/image-20240829194449196.png" alt="image-20240829194449196"></p><p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间不足时，后台线程也会主动刷盘。</p><h4 id="日志文件组："><a href="#日志文件组：" class="headerlink" title="日志文件组："></a>日志文件组：</h4><p>硬盘上存储的 redo log 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个<code>redo</code>日志文件大小都是一样的。</p><p>这个日志文件组采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p><img src="../images/image-20240829194506541.png" alt="image-20240829194506541" style="zoom: 50%;" /><p>在这个<strong>日志文件组</strong>中还有两个重要的属性分别是 <code>write pos、checkpoint</code>，分别表示当前记录的位置和当前要擦除的位置，每次更新，都会往后移。</p><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 redo log 记录。</p><img src="../images/image-20240829194530230.png" alt="image-20240829194530230" style="zoom:50%;" /><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p><img src="../images/image-20240829194554229.png" alt="image-20240829194554229" style="zoom:50%;" /><p>在 MySQL 8.0.30 之前可以通过 <code>innodb_log_files_in_group</code> 和 <code>innodb_log_file_size</code> 配置日志文件组的文件数和文件大小，但在 MySQL 8.0.30 及之后的版本中，这两个变量已被废弃，即使被指定也是用来计算 <code>innodb_redo_log_capacity</code> 的值。而日志文件组的文件数则固定为 32，文件大小则为 <code>innodb_redo_log_capacity / 32</code> 。</p><h3 id="binlog："><a href="#binlog：" class="headerlink" title="binlog："></a>binlog：</h3><p>redo log 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。</p><p>而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p><p>不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。</p><p>可以说 MySQL 数据库的<strong>数据备份、主备、主主、主从</strong>都离不开 binlog，需要依靠 binlog 来同步数据，保证数据一致性。</p><p>binlog 会记录所有涉及<strong>更新数据的逻辑操作</strong>，并且是<strong>顺序写</strong>。</p><h4 id="记录格式："><a href="#记录格式：" class="headerlink" title="记录格式："></a>记录格式：</h4><p>binlog 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><p>有三个值：</p><ul><li><p><strong>statement</strong>：指定statement，记录的是sql语句的原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p><p><img src="/../images/image-20240829194611246.png" alt="image-20240829194611246"></p><p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p></li><li><p><strong>row</strong>：为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p></li></ul><p><img src="/../images/image-20240829194634487.png" alt="image-20240829194634487"></p><p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p><p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p><p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗 IO 资源，影响执行速度。</p><ul><li><strong>mixed</strong>：所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。MySQL 会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式</li></ul><h4 id="写入机制："><a href="#写入机制：" class="headerlink" title="写入机制："></a>写入机制：</h4><p>事务执行过程中，会把日志写入binlog cache，事务提交的时候，把binglog cache的内容写到binglog中。因为一个事务的 binlog 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p><p>我们可以通过这个参数binlog_cache_size来控制每个binlog cache的大小，如果超出了这个的大小，就要暂存到磁盘上了。</p><p>binlog 日志刷盘流程如下</p><p><img src="/../images/image-20240829194651620.png" alt="image-20240829194651620"></p><ul><li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li><li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li></ul><p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>1</code>。</p><p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</p><p><img src="/../images/image-20240829194707449.png" alt="image-20240829194707449"></p><p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binlog 会丢失。</p><p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</p><p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p><p><img src="/../images/image-20240829194724782.png" alt="image-20240829194724782"></p><p>在出现 IO 瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p><p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的 binlog 日志。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><a href="https://javaguide.cn/database/mysql/mysql-logs.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">两阶段提交</a></h4><h3 id="undoolog："><a href="#undoolog：" class="headerlink" title="undoolog："></a>undoolog：</h3><p>每一个事务对数据的修改都会记录到undolog日志中，当执行事务过程中发生错误或需要回滚时，Mysql可以根据undolog日志进行恢复数据到事务执行前的状态。</p><p>undolog是一种逻辑日志，记录的是sql语句，比如事务执行一条delete语句，undolog会相对应的记录一条insert语句。同时undolog日志的信息也要被记录到redolog日志中。并且，undo-log 本身是会被删除清理的，例如 INSERT 操作，在事务提交之后就可以清除掉了；UPDATE&#x2F;DELETE 操作在事务提交不会立即删除，会加入 history list，由后台线程 purge 进行清理。</p><p>undo log 是采用 segment（段）的方式来记录的，每个 undo 操作在记录的时候占用一个 <strong>undo log segment</strong>（undo 日志段），undo log segment 包含在 <strong>rollback segment</strong>（回滚段）中。事务开始时，需要为其分配一个 rollback segment。每个 rollback segment 有 1024 个 undo log segment，这有助于管理多个并发事务的回滚需求。</p><p>通常情况下， <strong>rollback segment header</strong>（通常在回滚段的第一个页）负责管理 rollback segment。rollback segment header 是 rollback segment 的一部分，通常在回滚段的第一个页。<strong>history list</strong> 是 rollback segment header 的一部分，它的主要作用是记录所有已经提交但还没有被清理（purge）的事务的 undo log。这个列表使得 purge 线程能够找到并清理那些不再需要的 undo log 记录。</p><p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，InnoDB 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p><p>MySQL 数据库的<strong>数据备份、主备、主主、主从</strong>都离不开 binlog，需要依靠 binlog 来同步数据，保证数据一致性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-外键是什么？&quot;&gt;&lt;a href=&quot;#1-外键是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.外键是什么？&quot;&gt;&lt;/a&gt;1.外键是什么？&lt;/h2&gt;&lt;p&gt;外键是一种用来与其他表建立联系的字段的名称，它是另一张表的主键，外键可以重复，可以有空值。并</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://example.com/2024/08/29/Kafka/"/>
    <id>http://example.com/2024/08/29/Kafka/</id>
    <published>2024-08-29T11:23:54.051Z</published>
    <updated>2024-09-02T09:10:50.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka基础："><a href="#Kafka基础：" class="headerlink" title="Kafka基础："></a>Kafka基础：</h2><h3 id="Kafka是什么？"><a href="#Kafka是什么？" class="headerlink" title="Kafka是什么？"></a>Kafka是什么？</h3><p>Kafka 是一个分布式流式处理平台。</p><p>流平台具有三个关键功能：</p><p><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</p><p><strong>容错的持久化方式存储记录消息流</strong>：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</p><p><strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</p><p><strong>应用场景：</strong></p><ol><li><strong>消息队列</strong>：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li><li><strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流</li></ol><h3 id="和其他的消息队列相比，Kafka的优势在哪？"><a href="#和其他的消息队列相比，Kafka的优势在哪？" class="headerlink" title="和其他的消息队列相比，Kafka的优势在哪？"></a>和其他的消息队列相比，Kafka的优势在哪？</h3><p><strong>极致的性能</strong>：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</p><p><strong>生态系统兼容性强</strong>：Kafka 与周边生态系统的兼容性是最好的，尤其在大数据和流计算领域。</p><h3 id="队列模型？Kafka的消息模型是什么？"><a href="#队列模型？Kafka的消息模型是什么？" class="headerlink" title="队列模型？Kafka的消息模型是什么？"></a>队列模型？Kafka的消息模型是什么？</h3><p><strong>队列模型：早期的消息模型</strong></p><p><img src="/../images/image-20240901112441066.png" alt="image-20240901112441066"></p><p><strong>使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</strong>比如：我们生产者发送 100 条消息的话，两个消费者来消费，一般情况下两个消费者会按照消息发送的顺序各自消费一半。</p><p><strong>队列模型存在的问题：</strong></p><ol><li>消息丢失：在消息传递过程中可能会出现消息丢失的情况，这可能是由于网络故障、系统崩溃等原因导致的。</li><li>消息重复：在某些情况下，同一个消息可能会被发送多次，从而导致重复处理。</li><li>不能得到完整的消息内容。</li></ol><p><strong>发布-订阅模型:Kafka 消息模型</strong></p><p>发布-订阅模型主要是为了解决队列模型存在的问题。</p><p><img src="/../images/image-20240901112540790.png" alt="image-20240901112540790"></p><p>发布订阅模型（Pub-Sub） 使用<strong>主题（Topic）</strong> 作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p><p>举个例子来说明这个问题：</p><p>假设有一个名为”news”的主题，现在有三个订阅者A、B和C。在这个场景中：</p><ol><li>发布者向”news”主题发布了第一条新闻消息。</li><li>此时，订阅者A和B已经订阅了”news”主题，他们都会收到这条新闻消息。</li><li>过了一会儿，订阅者C也开始订阅”news”主题。</li><li>但是，由于第一条新闻消息已经在之前就被发布并且传播给了订阅者A和B，所以订阅者C在订阅”news”主题后并不会收到第一条新闻消息。</li></ol><p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p><p><strong>Kafka 采用的就是发布 - 订阅模型。</strong></p><p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p><h3 id="Kafka体系架构："><a href="#Kafka体系架构：" class="headerlink" title="Kafka体系架构："></a>Kafka体系架构：</h3><p><img src="/../images/eg1y1l18ts.png" alt="img"></p><p>Kafka 依靠 Zookeeper 做分布式协调服务，负责存储和管理 Kafka 集群中的元数据信息，包括集群中的 broker 信息、topic 信息、topic 的分区与副本信息等。</p><h3 id="Kafka-术语："><a href="#Kafka-术语：" class="headerlink" title="Kafka 术语："></a>Kafka 术语：</h3><ul><li>Producer：生产者，消息产生和发送端。</li><li>Broker：Kafka 实例，多个 broker 组成一个 Kafka 集群，通常一台机器部署一个 Kafka 实例，一个实例挂了不影响其他实例。</li><li>Consumer：消费者，拉取消息进行消费。 一个 topic 可以让若干个消费者进行消费，若干个消费者组成一个 Consumer Group 即消费组，一条消息只能被消费组中一个 Consumer 消费。</li><li>Topic：主题，服务端消息的逻辑存储单元。一个 topic 通常包含若干个 Partition 分区。</li><li>Partition：topic 的分区，分布式存储在各个 broker 中， 实现发布与订阅的负载均衡。若干个分区可以被若干个 Consumer 同时消费，达到消费者高吞吐量。一个分区拥有多个副本（Replica），这是Kafka在可靠性和可用性方面的设计。</li><li>message：消息，或称日志消息，是 Kafka 服务端实际存储的数据，每一条消息都由一个 key、一个 value 以及消息时间戳 timestamp 组成。</li><li>offset：偏移量，分区中的消息位置，由 Kafka 自身维护，Consumer 消费时也要保存一份 offset 以维护消费过的消息位置。</li></ul><h3 id="Kafka-特点："><a href="#Kafka-特点：" class="headerlink" title="Kafka 特点："></a>Kafka 特点：</h3><ul><li><strong>高吞吐量、低延迟</strong>：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li><li><strong>可扩展性</strong>：kafka集群支持热扩展</li><li><strong>持久性、可靠性</strong>：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li><li><strong>容错性</strong>：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li><li><strong>高并发</strong>：支持数千个客户端同时读写</li></ul><h2 id="Kafka的核心概念："><a href="#Kafka的核心概念：" class="headerlink" title="Kafka的核心概念："></a>Kafka的核心概念：</h2><h3 id="什么是-Producer、Consumer、Broker、Topic、Partition？"><a href="#什么是-Producer、Consumer、Broker、Topic、Partition？" class="headerlink" title="什么是 Producer、Consumer、Broker、Topic、Partition？"></a>什么是 Producer、Consumer、Broker、Topic、Partition？</h3><p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>，</p><p><img src="/../images/image-20240901112708118.png" alt="image-20240901112708118"></p><p>Kafka 比较重要的几个概念：</p><ol><li><strong>Producer（生产者）</strong> : 产生消息的一方。</li><li><strong>Consumer（消费者）</strong> : 消费消息的一方。</li><li><strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li></ol><p>每个 Broker 中又包含了 <strong>Topic 以及 Partition</strong> 这两个重要的概念：</p><p><strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</p><p><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这就表明一个 Topic 可以横跨多个 Broker 。如上图一样。</p><blockquote><p><strong>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。</strong></p></blockquote><h3 id="Kafka的多副本机制？有什么好处？"><a href="#Kafka的多副本机制？有什么好处？" class="headerlink" title="Kafka的多副本机制？有什么好处？"></a>Kafka的多副本机制？有什么好处？</h3><p>分区（Partition）中的多个副本之间会有一个叫做 leader 主副本，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p><blockquote><p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p></blockquote><p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong></p><ol><li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li><li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li></ol><h2 id="Zookeeper和Kafka："><a href="#Zookeeper和Kafka：" class="headerlink" title="Zookeeper和Kafka："></a>Zookeeper和Kafka：</h2><h3 id="Zookeeper在Kafka中的作用是什么？"><a href="#Zookeeper在Kafka中的作用是什么？" class="headerlink" title="Zookeeper在Kafka中的作用是什么？"></a>Zookeeper在Kafka中的作用是什么？</h3><p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p><p>Zookeeper 主要为 Kafka 做了下面这些事情：</p><ol><li><strong>Broker 注册</strong>：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li><li><strong>Topic 注册</strong>：在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li><li><strong>负载均衡</strong>：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li><li><strong>消息 消费进度Offset 记录：</strong>在消费者对指定消息分区进行消息消费的过程中，<strong>需要定时地将分区消息的消费进度Offset记录到Zookeeper上</strong>，以便在该消费者进行重启或者其他消费者重新接管该消息分区的消息消费后，能够从之前的进度开始继续进行消息消费。Offset在Zookeeper中由一个专门节点进行记录，其节点路径为:&#x2F;consumers&#x2F;[group_id]&#x2F;offsets&#x2F;[topic]&#x2F;[broker_id-partition_id]，节点内容就是Offset的值。</li></ol><h2 id="Kafka-消费顺序、消息丢失和重复消费"><a href="#Kafka-消费顺序、消息丢失和重复消费" class="headerlink" title="Kafka 消费顺序、消息丢失和重复消费"></a>Kafka 消费顺序、消息丢失和重复消费</h2><h3 id="Kafka-如何保证消息的消费顺序？"><a href="#Kafka-如何保证消息的消费顺序？" class="headerlink" title="Kafka 如何保证消息的消费顺序？"></a>Kafka 如何保证消息的消费顺序？</h3><p>Kafka 中 Partition(分区)是真正保存消息的地方，发送的消息都被放在了这里。而 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且可以给特定 Topic 指定多个 Partition。</p><p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能保证 Partition(分区) 中的消息有序。</strong></p><p><img src="/../images/image-20240901115225534.png" alt="image-20240901115225534"></p><blockquote><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p></blockquote><p>所以，就有一种很简单的保证消息消费顺序的方法：<strong>1 个 Topic 只对应一个 Partition</strong>。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p><p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,value（数据） 4 个参数。<strong>如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。</strong>并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表&#x2F;对象的 id 来作为 key 。</p><p>对于如何保证 Kafka 中消息消费的顺序，就有了下面两种方法：</p><ul><li>1 个 Topic 只对应一个 Partition。</li><li>（推荐）发送消息的时候指定 topic和Partition。</li></ul><h3 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a>如何保证消息不丢失？</h3><p>消息丢失分为三种情况：</p><p><strong>生产者消息丢失、消费者消息丢失、Broker消息丢失</strong></p><h4 id="生产者消息丢失"><a href="#生产者消息丢失" class="headerlink" title="生产者消息丢失"></a>生产者消息丢失</h4><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，返回值是一个Future对象，我们可以通过调用 <code>get()</code>方法获取调用结果，这样的操作会让它变为了同步操作，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//创建数据</span></span><br><span class="line">    ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(</span><br><span class="line">            <span class="string">&quot;test&quot;</span>,<span class="string">&quot;key&quot;</span>+i,<span class="string">&quot;value&quot;</span>+i</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过生产者对象把数据发送到kafka</span></span><br><span class="line">    <span class="comment">//异步发送数据</span></span><br><span class="line">    Future&lt;RecordMetadata&gt; future = stringStringKafkaProducer.send(record);</span><br><span class="line">    System.out.println(<span class="string">&quot;数据发送中&quot;</span>);</span><br><span class="line">    <span class="comment">//同步发送数据</span></span><br><span class="line">    future.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二，可以采用为其添加回调函数的形式，使用异步方式发送数据，代码如下：</p><p>在<code>send()</code>方法中创建一个<code>Callback()</code>匿名类,在匿名内中判断数据是否发送成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步发送数据</span></span><br><span class="line">Future&lt;RecordMetadata&gt; future = stringStringKafkaProducer.send(record, <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据发送成功&quot;</span> + recordMetadata);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据发送失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p><p><strong>另外，这里推荐为 Producer 的<code>retries</code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了。</strong></p><h4 id="消费者消息丢失"><a href="#消费者消息丢失" class="headerlink" title="消费者消息丢失"></a>消费者消息丢失</h4><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p><img src="/../images/image-20240901141046077.png" alt="image-20240901141046077"></p><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p><p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被<strong>重新消费的问题</strong>。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h4 id="Broker消息丢失"><a href="#Broker消息丢失" class="headerlink" title="Broker消息丢失"></a>Broker消息丢失</h4><p> Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</p><p><strong>设置 acks &#x3D; all</strong></p><p>解决办法就是我们设置 <strong>acks &#x3D; all</strong>。acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p><p>acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 <strong>acks &#x3D; all</strong> 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应. 这种模式是最高级别的，也是最安全的，可以确保不止一个 Broker 接收到了消息. 该模式的延迟会很高.</p><p><strong>设置 unclean.leader.election.enable &#x3D; false</strong></p><p>我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable &#x3D; false</strong> 的话，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p><p><strong>设置 replication.factor &gt;&#x3D; 3</strong></p><p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;&#x3D; 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><p><strong>设置 min.insync.replicas &gt; 1</strong></p><p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p>为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor &#x3D; min.insync.replicas + 1</strong>。</p><h3 id="Kafka-如何保证消息不重复消费？"><a href="#Kafka-如何保证消息不重复消费？" class="headerlink" title="Kafka 如何保证消息不重复消费？"></a>Kafka 如何保证消息不重复消费？</h3><p><strong>kafka 出现消息重复消费的原因：</strong></p><ul><li>服务端侧已经消费的数据没有成功提交 offset（根本原因），触发了重试机制。</li><li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li></ul><p><strong>解决方案：</strong></p><ul><li><p>消费消息服务做<strong>幂等校验</strong>，比如 Redis 的 set、MySQL 的主键等天然的幂等功能。这种方法最有效。</p></li><li><p>将 <strong><code>enable.auto.commit</code></strong> 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：<strong>什么时候提交 offset 合适？</strong></p><ul><li><p>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</p></li><li><p>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</p></li></ul></li></ul><h2 id="Kafka消息重试机制"><a href="#Kafka消息重试机制" class="headerlink" title="Kafka消息重试机制"></a>Kafka消息重试机制</h2><h3 id="消费失败会怎么样？"><a href="#消费失败会怎么样？" class="headerlink" title="消费失败会怎么样？"></a>消费失败会怎么样？</h3><p>在消费过程中，当其中一个消息消费异常时，会不会卡住后续队列消息的消费？这样业务岂不是卡住了？</p><p>在默认配置下，当消费异常会进行重试，重试多次后会跳过当前消息，继续进行后续消息的消费，不会一直卡在当前消息。因此，即使某个消息消费异常，Kafka 消费者仍然能够继续消费后续的消息，不会一直卡在当前消息，保证了业务的正常进行。</p><h3 id="默认会重试多少次？"><a href="#默认会重试多少次？" class="headerlink" title="默认会重试多少次？"></a>默认会重试多少次？</h3><p>默认配置下，消费异常会进行重试，重试次数是多少, 重试是否有时间间隔？</p><p>Kafka 消费者在默认配置下会进行<strong>最多 10 次 的重试</strong>，每次重试的<strong>时间间隔为 0</strong>，即立即进行重试。如果在 10 次重试后仍然无法成功消费消息，<strong>则不再进行重试，消息将被视为消费失败</strong>。</p><h3 id="如何自定义重试次数以及时间间隔"><a href="#如何自定义重试次数以及时间间隔" class="headerlink" title="如何自定义重试次数以及时间间隔?"></a>如何自定义重试次数以及时间间隔?</h3><p>从上面的代码可以知道，默认错误处理器的重试次数以及时间间隔是由 <code>FixedBackOff</code> 控制的，<code>FixedBackOff</code> 是 <code>DefaultErrorHandler</code> 初始化时默认的。所以自定义重试次数以及时间间隔，只需要在 <code>DefaultErrorHandler</code> 初始化的时候传入自定义的 <code>FixedBackOff</code> 即可。重新实现一个 <code>KafkaListenerContainerFactory</code> ，调用 <code>setCommonErrorHandler</code> 设置新的自定义的错误处理器就可以实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> KafkaListenerContainerFactory <span class="title function_">kafkaListenerContainerFactory</span><span class="params">(ConsumerFactory&lt;String, String&gt; consumerFactory)</span> &#123;</span><br><span class="line">    <span class="type">ConcurrentKafkaListenerContainerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentKafkaListenerContainerFactory</span>();</span><br><span class="line">    <span class="comment">// 自定义重试时间间隔以及次数</span></span><br><span class="line">    <span class="type">FixedBackOff</span> <span class="variable">fixedBackOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOff</span>(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line">    factory.setCommonErrorHandler(<span class="keyword">new</span> <span class="title class_">DefaultErrorHandler</span>(fixedBackOff));</span><br><span class="line">    factory.setConsumerFactory(consumerFactory);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何在重试失败后进行告警"><a href="#如何在重试失败后进行告警" class="headerlink" title="如何在重试失败后进行告警?"></a>如何在重试失败后进行告警?</h3><p>自定义重试失败后逻辑，需要手动实现，以下是一个简单的例子，重写 <code>DefaultErrorHandler</code> 的 <code>handleRemaining</code> 函数，加上自定义的告警等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelErrorHandler</span> <span class="keyword">extends</span> <span class="title class_">DefaultErrorHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DelErrorHandler</span><span class="params">(FixedBackOff backOff)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">null</span>,backOff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRemaining</span><span class="params">(Exception thrownException, List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records, Consumer&lt;?, ?&gt; consumer, MessageListenerContainer container)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.handleRemaining(thrownException, records, consumer, container);</span><br><span class="line">        log.info(<span class="string">&quot;重试多次失败&quot;</span>);</span><br><span class="line">        <span class="comment">// 自定义操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultErrorHandler</code> 只是默认的一个错误处理器，Spring Kafka 还提供了 <code>CommonErrorHandler</code> 接口。手动实现 <code>CommonErrorHandler</code> 就可以实现更多的自定义操作，有很高的灵活性。例如根据不同的错误类型，实现不同的重试逻辑以及业务逻辑等。</p><h3 id="重试失败后的数据如何再次处理"><a href="#重试失败后的数据如何再次处理" class="headerlink" title="重试失败后的数据如何再次处理?"></a>重试失败后的数据如何再次处理?</h3><p>当达到最大重试次数后，数据会直接被跳过，继续向后进行。当代码修复后，如何重新消费这些重试失败的数据呢？</p><p><strong>死信队列（Dead Letter Queue，简称 DLQ）</strong> 是消息中间件中的一种特殊队列。它主要用于处理无法被消费者正确处理的消息，通常是因为消息格式错误、处理失败、消费超时等情况导致的消息被”丢弃”或”死亡”的情况。当消息进入队列后，消费者会尝试处理它。如果处理失败，或者超过一定的重试次数仍无法被成功处理，消息可以发送到死信队列中，而不是被永久性地丢弃。在死信队列中，可以进一步分析、处理这些无法正常消费的消息，以便定位问题、修复错误，并采取适当的措施。</p><p><code>@RetryableTopic</code> 是 Spring Kafka 中的一个注解,它用于配置某个 Topic 支持消息重试，更推荐使用这个注解来完成重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重试 5 次，重试间隔 100 毫秒,最大间隔 1 秒</span></span><br><span class="line"><span class="meta">@RetryableTopic(</span></span><br><span class="line"><span class="meta">        attempts = &quot;5&quot;,</span></span><br><span class="line"><span class="meta">        backoff = @Backoff(delay = 100, maxDelay = 1000)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &#123;KafkaConst.TEST_TOPIC&#125;, groupId = &quot;apple&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">customer</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;kafka customer:&#123;&#125;&quot;</span>, message);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(message);</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当达到最大重试次数后，如果仍然无法成功处理消息，消息会被发送到对应的死信队列中。对于死信队列的处理，既可以用 <code>@DltHandler</code> 处理，也可以使用 <code>@KafkaListener</code> 重新消费。</p><h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><h3 id="数据同步一致性问题"><a href="#数据同步一致性问题" class="headerlink" title="数据同步一致性问题"></a>数据同步一致性问题</h3><p>这里有这样一个场景：一个分区有3个副本，一个Leader和两个Follower。Leader副本作为数据的读写副本，所以生产者的数据都会发送给leader副本，而两个follower副本会周期性地同步leader副本的数据，但是因为网络，资源等因素的制约，同步数据的过程是有一定延迟的，所以3个副本之间的数据可能是不同的。</p><p><img src="/../images/image-20240901161640074.png" alt="image-20240901161640074"></p><p>此时，假设leader副本因为意外原因宕掉了，那么Kafka为了提高分区可用性，此时会选择2个follower副本中的一个作为Leader对外提供数据服务。此时我们就会发现，对于消费者而言，之前leader副本能访问的数据可以到D，但是重新选择leader副本后，能访问的数据就只能到C了，这样消费者就会认为数据丢失了，也就是所谓的数据不一致了。</p><p><img src="/../images/image-20240901161811902.png" alt="image-20240901161811902"></p><p>为了提升数据的一致性，Kafka引入了高水位（HW ：High Watermark）机制，Kafka在不同的副本之间维护了一个<strong>水位线的机制</strong>（其实也是一个偏移量的概念），消费者只能读取到水位线以下的的数据。<strong>这就是所谓的木桶理论：木桶中容纳水的高度，只能是水桶中最短的那块木板的高度</strong>。这里将整个分区看成一个木桶，其中的数据看成水，而每一个副本就是木桶上的一块木板，那么这个分区（木桶）可以被消费者消费的数据（容纳的水）其实就是数据最少的那个副本的最后数据位置（木板高度）。</p><p>也就是说，消费者一开始在消费Leader的时候，虽然Leader副本中已经有a、b、c、d 4条数据，但是由于高水位线的限制，所以也只能消费到a、b这两条数据。</p><p><img src="/../images/image-20240901161933715.png" alt="image-20240901161933715"></p><p>这样即使leader挂掉了，但是对于消费者来讲，消费到的数据其实还是一样的，因为它能看到的数据是一样的，也就是说，消费者不会认为数据不一致。</p><p>不过，因为follower要求和leader的日志数据严格保持一致，所以就需要根据现在Leader的数据偏移量值对其他的副本进行数据截断（truncate）操作。</p><p><img src="/../images/image-20240901162119124.png" alt="image-20240901162119124"></p><h3 id="HW在副本之间的传递"><a href="#HW在副本之间的传递" class="headerlink" title="HW在副本之间的传递"></a>HW在副本之间的传递</h3><p>HW高水位线会随着follower的数据同步操作，而不断上涨，也就是说，follower同步的数据越多，那么水位线也就越高，那么消费者能访问的数据也就越多。</p><p>首先，初始状态下，Leader和Follower都没有数据，所以和偏移量相关的值都是初始值0，而由于Leader需要管理follower，所以也包含着follower的相关偏移量（LEO）数据。</p><p><img src="/../images/image-20240901162256010.png" alt="image-20240901162256010"></p><p>生产者向Leader发送两条数据，Leader收到数据后，会更新自身的偏移量信息。</p><p><strong>Leader副本偏移量更新：</strong>LEO&#x3D;LEO+2&#x3D;2</p><p><img src="/../images/image-20240901162347365.png" alt="image-20240901162347365"></p><p>接下来，Follower开始同步Leader的数据，同步数据时，会将自身的LEO值作为参数传递给Leader。此时，Leader会将数据传递给Follower，且同时Leader会根据所有副本的LEO值更新HW。</p><p><img src="/../images/image-20240901162529433.png" alt="image-20240901162529433"></p><p><strong>Leader副本偏移量更新：</strong>HW &#x3D; Math.max[HW, min(LeaderLEO，F1-LEO，F2-LEO)]</p><p><img src="/../images/image-20240901163959069.png" alt="image-20240901163959069"></p><p>由于两个Follower的数据拉取速率不一致，所以Follower-1抓取了2条数据，而Follower-2抓取了1条数据。Follower收到数据后，会将数据写入文件，并更新自身的偏移量信息。</p><p><strong>Follower-1副本偏移量更新：</strong></p><p>LEO&#x3D;LEO+2&#x3D;2</p><p>HW &#x3D; Math.min[LeaderHW, LEO]</p><p><strong>Follower-2副本偏移量更新</strong>：</p><p>LEO&#x3D;LEO+1&#x3D;1</p><p>HW &#x3D; Math.min[LeaderHW, LEO]</p><p><img src="/../images/image-20240901164231768.png" alt="image-20240901164231768"></p><p>接下来Leader收到了生产者的数据C，那么此时会根据相同的方式更新自身的偏移量信息</p><p><strong>Leader副本偏移量更新</strong>：LEO&#x3D;LEO+1&#x3D;3</p><p><img src="/../images/image-20240901164310530.png" alt="image-20240901164310530"></p><p>follower接着向Leader发送Fetch请求，同样会将最新的LEO作为参数传递给Leader。Leader收到请求后，会更新自身的偏移量信息。</p><p><strong>Leader副本偏移量更新</strong>：HW &#x3D; Math.max[HW, min(LeaderLEO，F1-LEO，F2-LEO)]</p><p><img src="/../images/image-20240901164343245.png" alt="image-20240901164343245"></p><p>此时，Leader会将数据发送给Follower，同时也会将HW一起发送。</p><p><img src="/../images/image-20240901164359895.png" alt="image-20240901164359895"></p><p>Follower收到数据后，会将数据写入文件，并更新自身偏移量信息</p><p><strong>Follower-1副本偏移量更新：</strong></p><p>LEO&#x3D;LEO+1&#x3D;3</p><p>HW &#x3D; Math.min[LeaderHW, LEO]</p><p><strong>Follower-2副本偏移量更新：</strong></p><p>LEO&#x3D;LEO+1&#x3D;2</p><p>HW &#x3D; Math.min[LeaderHW, LEO]</p><p><img src="/../images/image-20240901164501185.png" alt="image-20240901164501185"></p><p>因为Follower会不断重复Fetch数据的过程，所以前面的操作会不断地重复。最终，follower副本和Leader副本的数据和偏移量是保持一致的。</p><p><img src="/../images/image-20240901164516595.png" alt="image-20240901164516595"></p><p>上面演示了副本列表ISR中Follower副本和Leader副本之间HW偏移量的变化过程，但特殊情况是例外的。比如当前副本列表ISR中，只剩下了Leader一个副本的场合下，是不需要等待其他副本的，直接推高HW即可。</p><h2 id="消费数据："><a href="#消费数据：" class="headerlink" title="消费数据："></a>消费数据：</h2><h3 id="Kafka中offset-偏移量-有什么用？"><a href="#Kafka中offset-偏移量-有什么用？" class="headerlink" title="Kafka中offset(偏移量)有什么用？"></a>Kafka中offset(偏移量)有什么用？</h3><p>偏移量（Offset）是一个用来标识每个消息在分区内的唯一位置的整数。偏移量是递增的，表示消息在分区内的顺序。</p><p>它提供了以下功能：</p><ol><li><strong>消息定位</strong>：偏移量允许消费者从指定的位置读取消息。例如，消费者可以从最新的消息开始消费，也可以选择从较早的偏移量开始消费。</li><li><strong>消息跟踪</strong>：偏移量可以帮助消费者追踪其消费进度。消费者可以通过保存已消费消息的偏移量来记录自己的消费进度，以便下次启动时从上次停止的地方继续消费。</li><li><strong>幂等性</strong>：偏移量可以确保消息仅被消费一次。消费者可以根据偏移量判断是否已经消费过某条消息，从而避免重复消费。</li><li><strong>数据恢复</strong>：如果消费者意外关闭或发生故障，它可以利用保存的偏移量重新连接到 Kafka，并从上次中断的位置继续消费。</li><li><strong>数据删除</strong>：Kafka 根据保留策略和分区大小自动删除旧的消息。偏移量决定了哪些消息应该被删除，哪些消息应该保留在磁盘上。</li></ol><h3 id="Kafka中的消费者偏移量是如何管理的？"><a href="#Kafka中的消费者偏移量是如何管理的？" class="headerlink" title="Kafka中的消费者偏移量是如何管理的？"></a>Kafka中的消费者偏移量是如何管理的？</h3><p>Kafka中的消费者偏移量由两部分组成：Topic和Partition。对于每个消费者组，Kafka都会为其维护在每个 Partition 上的偏移量，以便在处理消息时可以准确地跟踪进度。</p><p>消费者偏移量的管理可以通过以下方式进行：</p><p>手动提交偏移量：消费者可以通过调用commitSync或commitAsync方法手动提交偏移量到Kafka。手动提交偏移量的方式需要开发者在适当的时机调用提交方法，确保消费者处理完消息后再提交偏移量。这种方式对于灵活性和精确控制偏移量非常有用，但需要开发者自行考虑提交的时机和异常处理。</p><p>自动提交偏移量：消费者可以配置为在后台自动提交偏移量。这意味着消费者会定期自动将已经处理的消息的偏移量提交给Kafka，而不需要开发者手动处理。通过配置参数enable.auto.commit为true，以及设置auto.commit.interval.ms参数来控制自动提交的频率。自动提交偏移量简化了管理，但可能会导致消息的重复处理或丢失，因此需要根据具体业务场景谨慎配置。</p><h3 id="Kafka的偏移量提交"><a href="#Kafka的偏移量提交" class="headerlink" title="Kafka的偏移量提交"></a>Kafka的偏移量提交</h3><p><strong>分为自动提交和手动提交</strong></p><h4 id="自动提交："><a href="#自动提交：" class="headerlink" title="自动提交："></a>自动提交：</h4><p>Kafka通过<code>auto.commit.interval.ms</code>设置自动提交的时间间隔，默认为5000毫秒。</p><p><strong>造成的问题：</strong>可能导致消息重复消费。比如在3秒的时候生产者重启了，前几秒的偏移量还没有提交，就会导致消息重复消费。</p><h4 id="手动提交："><a href="#手动提交：" class="headerlink" title="手动提交："></a>手动提交：</h4><p>分为异步提交和同步提交。</p><p>异步提交不用管提交的结果是什么，同步提交需要等待提交的结果，如果提交的结果失败，需要进行重试，同步提交会阻塞线程，影响吞吐量。</p><p><strong>造成的问题：</strong>可能会造成漏消费的问题。比如，现在手动提交了一个偏移量，但这个数据还没进行处理消费者就宕机重启了，此时重启的消费者就会漏消费数据。</p><h3 id="消费者组："><a href="#消费者组：" class="headerlink" title="消费者组："></a>消费者组：</h3><p><img src="/../images/image-20240902105704005.png" alt="image-20240902105704005"></p><p><strong>一个分区不能被多个消费者消费，但一个消费者可以消费多个分区。</strong>如下图所示：</p><p><img src="/../images/image-20240902105753957.png" alt="image-20240902105753957"></p><p><img src="/../images/image-20240902105810423.png" alt="image-20240902105810423"></p><p><strong>消费者组中的消费者可以大于分区的数量，多的消费者可以作为备份消费者。</strong>但一个消费者宕机了，多余的消费者会顶替宕机的消费者。</p><p><img src="/../images/image-20240902110954962.png" alt="image-20240902110954962"></p><p>为了让新的消费者继续从宕机的消费者进行消费数据，Kafka中提供了一个内部主题保证消息的顺序消费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Kafka基础：&quot;&gt;&lt;a href=&quot;#Kafka基础：&quot; class=&quot;headerlink&quot; title=&quot;Kafka基础：&quot;&gt;&lt;/a&gt;Kafka基础：&lt;/h2&gt;&lt;h3 id=&quot;Kafka是什么？&quot;&gt;&lt;a href=&quot;#Kafka是什么？&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://example.com/2024/08/29/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/08/29/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2024-08-29T11:23:54.048Z</published>
    <updated>2024-08-29T07:48:08.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中有没有有顺序的set集合？"><a href="#Java中有没有有顺序的set集合？" class="headerlink" title="Java中有没有有顺序的set集合？"></a>Java中有没有有顺序的set集合？</h2><p><strong>LinkedHashSet</strong>:</p><ul><li><p>特点</p><p>:</p><ul><li><code>LinkedHashSet</code> 继承自 <code>HashSet</code>，但它维护了一个链表来记录元素的插入顺序。</li><li><code>LinkedHashSet</code> 保证了元素的插入顺序，即元素的遍历顺序与添加顺序相同。</li><li><code>LinkedHashSet</code> 的实现性能与 <code>HashSet</code> 类似，但由于维护了链表，因此在某些操作上可能会略微慢一些。</li></ul></li></ul><p><strong>TreeSet</strong>:</p><ul><li><p>特点</p><p>:</p><ul><li><code>TreeSet</code> 实现了一个基于红黑树的 NavigableSet 接口，它可以自然排序或根据提供的 Comparator 排序。</li><li><code>TreeSet</code> 保证了元素的排序，即元素的遍历顺序按照自然排序或提供的 Comparator 排序。</li><li><code>TreeSet</code> 提供了多种排序相关的方法，如 <code>headSet()</code>, <code>tailSet()</code>, <code>subSet()</code> 等，可以根据需要获取排序后的子集。</li></ul></li></ul><p><strong>总结</strong></p><ul><li><strong>LinkedHashSet</strong> 保持元素的插入顺序，适合于需要保留元素添加顺序的场景。</li><li><strong>TreeSet</strong> 保持元素的自然排序或提供的排序规则，适合于需要排序的场景。</li></ul><h2 id="一个实体类中有get和set方法，现在要对set方法要加锁，get方法要并发执行，怎么实现？"><a href="#一个实体类中有get和set方法，现在要对set方法要加锁，get方法要并发执行，怎么实现？" class="headerlink" title="一个实体类中有get和set方法，现在要对set方法要加锁，get方法要并发执行，怎么实现？"></a>一个实体类中有get和set方法，现在要对set方法要加锁，get方法要并发执行，怎么实现？</h2><p><strong>方法一：</strong>使用 synchronized 关键字</p><p>你可以使用 <code>synchronized</code> 关键字来修饰 <code>set</code> 方法，确保在多线程环境下只有一个线程能进入 <code>set</code> 方法。<code>get</code> 方法不需要加锁，因此可以并发执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeEntity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 用于同步的锁对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong>使用 ReentrantLock</p><p>另一种方法是使用 <code>ReentrantLock</code>，它提供了比 <code>synchronized</code> 更细粒度的控制。你可以创建一个 <code>ReentrantLock</code> 对象，并在 <code>set</code> 方法中获取锁，在方法退出时释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeEntity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 用于同步的锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三</strong>：可以使用读写锁，允许读操作并发执行，同时确保写操作（即 set 方法）是互斥的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeEntity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述方法，你可以确保 <code>set</code> 方法在多线程环境下是同步的，而 <code>get</code> 方法可以并发执行。这样既能保证数据的一致性，又能提高并发性能。</p><h2 id="读写锁："><a href="#读写锁：" class="headerlink" title="读写锁："></a>读写锁：</h2><p>分为读锁和写锁。</p><p><strong>读锁：</strong></p><ul><li><p>在多个线程尝试获取读锁时，它们都可以获取读锁并进行读操作。</p></li><li><p>读锁的获取不会影响其他读锁的获取。</p></li></ul><p><strong>写锁：</strong></p><ul><li><p>当一个线程来获取写锁时，如果此时有另一个线程已经获得了读锁或者写锁，那么该线程需要等待。</p></li><li><p>写锁的获取会阻塞所有其他的读锁和写锁。</p></li></ul><p><strong>总结：</strong></p><ol><li><strong>允许多个读操作并发，读操作之间不会互相阻塞</strong>。</li><li><strong>写操作独占锁，写操作会阻塞所有其他的读写操作。</strong></li><li><strong>写操作会阻塞读操作，新的读操作会被阻塞，直到写操作完成。</strong></li></ol><p><strong>示例代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">public class ReadWriteLockExample &#123;</span><br><span class="line">    private final ReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    private final Object data = new Object();</span><br><span class="line"></span><br><span class="line">    public void readData() &#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;Reading data...&quot;);</span><br><span class="line">            // 读取数据</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writeData() &#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;Writing data...&quot;);</span><br><span class="line">            // 更新数据</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReadWriteLockExample example = new ReadWriteLockExample();</span><br><span class="line"></span><br><span class="line">        // 创建读线程</span><br><span class="line">        Thread readThread1 = new Thread(example::readData);</span><br><span class="line">        Thread readThread2 = new Thread(example::readData);</span><br><span class="line"></span><br><span class="line">        // 创建写线程</span><br><span class="line">        Thread writeThread = new Thread(example::writeData);</span><br><span class="line"></span><br><span class="line">        // 启动线程</span><br><span class="line">        readThread1.start();</span><br><span class="line">        readThread2.start();</span><br><span class="line">        writeThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，当有读操作正在进行时，新的写操作会被阻塞，直到所有读操作完成。同样地，当有写操作正在进行时，新的读操作会被阻塞，直到写操作完成。</p><p>通过这种方式，读写锁可以确保读操作之间可以并发执行，但写操作需要独占锁，以避免数据不一致的问题。</p><h2 id="线程池的拒绝策略？"><a href="#线程池的拒绝策略？" class="headerlink" title="线程池的拒绝策略？"></a>线程池的拒绝策略？</h2><p>线程池的拒绝策略是指当线程池中的任务队列已满并且所有工作线程都在忙于处理任务时，线程池如何处理新提交的任务。Java 中的 <code>java.util.concurrent.ThreadPoolExecutor</code> 类提供了四种默认的拒绝策略：</p><h3 id="1-AbortPolicy-中止策略"><a href="#1-AbortPolicy-中止策略" class="headerlink" title="1.AbortPolicy (中止策略)"></a>1.<code>AbortPolicy</code> (中止策略)</h3><ul><li><strong>描述</strong>:<ul><li>当线程池无法接受新任务时抛出 <code>RejectedExecutionException</code> 异常。</li><li>这是最简单的策略，也是默认的策略。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当系统资源有限时，可以使用此策略来避免过度负载。</li><li>不适用于必须处理所有任务的场景。</li></ul></li></ul><h3 id="2-CallerRunsPolicy-调用者运行策略"><a href="#2-CallerRunsPolicy-调用者运行策略" class="headerlink" title="2. CallerRunsPolicy (调用者运行策略)"></a>2. <code>CallerRunsPolicy</code> (调用者运行策略)</h3><ul><li><strong>描述</strong>:<ul><li>当线程池无法接受新任务时，提交任务的线程会自己执行该任务。</li><li>这意味着提交任务的线程将直接执行任务，而不是等待线程池中的线程空闲。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当系统资源有限但又必须处理所有任务时，可以使用此策略。</li><li>可以防止任务丢失，但可能导致提交任务的线程阻塞。</li></ul></li></ul><h3 id="3-DiscardPolicy-丢弃策略"><a href="#3-DiscardPolicy-丢弃策略" class="headerlink" title="3. DiscardPolicy (丢弃策略)"></a>3. <code>DiscardPolicy</code> (丢弃策略)</h3><ul><li><strong>描述</strong>:<ul><li>当线程池无法接受新任务时，默默地丢弃任务而不执行。</li><li>不抛出异常也不通知调用者。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当系统资源有限且可以容忍部分任务丢失时，可以使用此策略。</li><li>不适用于必须处理所有任务的场景。</li></ul></li></ul><h3 id="4-DiscardOldestPolicy-丢弃最旧任务策略"><a href="#4-DiscardOldestPolicy-丢弃最旧任务策略" class="headerlink" title="4. DiscardOldestPolicy (丢弃最旧任务策略)"></a>4. <code>DiscardOldestPolicy</code> (丢弃最旧任务策略)</h3><ul><li><strong>描述</strong>:<ul><li>当线程池无法接受新任务时，移除队列中最旧的任务并尝试再次提交新任务。</li><li>这样做是为了腾出空间来接受新任务。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当系统资源有限且可以容忍部分任务丢失时，可以使用此策略。</li><li>可以防止新任务被丢弃，但可能导致较旧的任务丢失。</li></ul></li></ul><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolRejectPolicyExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建线程池，使用不同的拒绝策略</span><br><span class="line">        ThreadPoolExecutor executor1 = new ThreadPoolExecutor(</span><br><span class="line">                2, 2, 1, TimeUnit.MINUTES,</span><br><span class="line">                new ArrayBlockingQueue&lt;&gt;(2),</span><br><span class="line">                new ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor executor2 = new ThreadPoolExecutor(</span><br><span class="line">                2, 2, 1, TimeUnit.MINUTES,</span><br><span class="line">                new ArrayBlockingQueue&lt;&gt;(2),</span><br><span class="line">                new ThreadPoolExecutor.DiscardPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor executor3 = new ThreadPoolExecutor(</span><br><span class="line">                2, 2, 1, TimeUnit.MINUTES,</span><br><span class="line">                new ArrayBlockingQueue&lt;&gt;(2),</span><br><span class="line">                new ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor executor4 = new ThreadPoolExecutor(</span><br><span class="line">                2, 2, 1, TimeUnit.MINUTES,</span><br><span class="line">                new ArrayBlockingQueue&lt;&gt;(2),</span><br><span class="line">                new ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 提交任务</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Runnable task = () -&gt; System.out.println(&quot;Executing task &quot; + i);</span><br><span class="line"></span><br><span class="line">            executor1.submit(task);</span><br><span class="line">            executor2.submit(task);</span><br><span class="line">            executor3.submit(task);</span><br><span class="line">            executor4.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 关闭线程池</span><br><span class="line">        executor1.shutdown();</span><br><span class="line">        executor2.shutdown();</span><br><span class="line">        executor3.shutdown();</span><br><span class="line">        executor4.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了四个线程池，分别使用了四种不同的拒绝策略。每个线程池的最大线程数为 2，最大队列大小也为 2。当我们尝试提交 5 个任务时，由于队列已满，线程池将根据各自的拒绝策略来处理超出的任务。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>如果希望确保所有任务都能得到处理，可以使用 <code>CallerRunsPolicy</code>。如果希望避免过度负载，可以使用 <code>AbortPolicy</code>。如果可以容忍部分任务丢失，可以使用 <code>DiscardPolicy</code> 或 <code>DiscardOldestPolicy</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java中有没有有顺序的set集合？&quot;&gt;&lt;a href=&quot;#Java中有没有有顺序的set集合？&quot; class=&quot;headerlink&quot; title=&quot;Java中有没有有顺序的set集合？&quot;&gt;&lt;/a&gt;Java中有没有有顺序的set集合？&lt;/h2&gt;&lt;p&gt;&lt;stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://example.com/2024/08/29/AQS/"/>
    <id>http://example.com/2024/08/29/AQS/</id>
    <published>2024-08-29T11:23:54.043Z</published>
    <updated>2024-08-29T11:25:42.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h2><p>AQS翻译过来就是抽象队列同步器，它就是一个抽象类，主要用来构建锁和同步锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS 为构建锁和同步器提供了一些通用功能的实现，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如<code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p><h2 id="AQS的原理是什么？"><a href="#AQS的原理是什么？" class="headerlink" title="AQS的原理是什么？"></a>AQS的原理是什么？</h2><p>AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求这个资源的线程设置为有效的工作线程，并且将该共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列里。</p><p><strong>CLH是一个虚拟的双向队列，即不存在队列的实例，仅存在节点之间的关联关系</strong>。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在CLH锁队列中，一个节点就是一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p><p>CLH 队列结构如同：</p><p><img src="/../images/image-20240829192441416.png" alt="image-20240829192441416"></p><p>AQS(<code>AbstractQueuedSynchronizer</code>)的核心原理图如下：</p><p><img src="/../images/image-20240829192528302.png" alt="image-20240829192528302"></p><p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>线程等待队列</strong> 来完成获取资源线程的排队工作。</p><p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 共享变量，使用volatile修饰保证线程可见性</span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。</p><p>以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p><p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，<code>state</code> 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code>countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p><h2 id="Semaphore有什么用？"><a href="#Semaphore有什么用？" class="headerlink" title="Semaphore有什么用？"></a>Semaphore有什么用？</h2><p><code>synchronized</code>和<code>ReentrantLock</code>都是一次只允许一个线程访问某个资源，而Semaphore(信号量)可以用来控制同时访问特定资源的线程数量。</p><p>Semaphore 的使用简单，假设有 N(N&gt;5) 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 初始共享资源数量</span><br><span class="line">final Semaphore semaphore = new Semaphore(5);</span><br><span class="line">// 获取1个许可</span><br><span class="line">semaphore.acquire();</span><br><span class="line">// 释放1个许可</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p><p><code>Semaphore</code> 有两种模式：</p><ul><li><p><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</p></li><li><p><strong>非公平模式：</strong> 抢占式的。</p></li></ul><p><code>Semaphore</code> 对应的两个构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p><p><code>Semaphore</code> 通常用于那些资源有明确访问数量限制的场景比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）</p><p>假设我们要实现的是基于令牌桶算法的限流，其基本思想是在 Redis 中为每个客户端维护一个令牌桶，每个令牌代表一次请求许可。当客户端请求时，先检查令牌桶中是否有足够的令牌，如果有，则减少相应数量的令牌并允许请求通过；如果没有足够的令牌，则拒绝请求。</p><h2 id="SemaPhore的原理是什么？"><a href="#SemaPhore的原理是什么？" class="headerlink" title="SemaPhore的原理是什么？"></a>SemaPhore的原理是什么？</h2><p>Semaphore是共享锁的一种实现，它默认构造AQS的state值为permits，可以将permits的值理解为许可证的数量，只有拿到许可证的线程可以执行成功。</p><p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取1个许可证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享模式下获取许可证，获取成功则返回，失败则加入阻塞队列，挂起线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 尝试获取许可证，arg为获取许可证个数，当可用许可证数减当前获取的许可证数结果小于0,则创建一个节点加入阻塞队列，挂起当前线程。</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放一个许可证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放共享锁，同时会唤醒同步队列中的一个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//释放共享锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">      <span class="comment">//唤醒同步队列中的一个线程</span></span><br><span class="line">      doReleaseShared();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="CountDownLatch有什么用？"><a href="#CountDownLatch有什么用？" class="headerlink" title="CountDownLatch有什么用？"></a>CountDownLatch有什么用？</h2><p><code>CountDownLatch</code>允许<code>count</code>个线程阻塞在一个地方，知道所有的线程的任务执行完毕为止。</p><p><code>CountDownLatch</code>是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何方法能够修改这个值，当<code>CountDownLatch</code>被使用完毕后，它就不能再次被使用。</p><h2 id="CountDownLatch的原理是什么？"><a href="#CountDownLatch的原理是什么？" class="headerlink" title="CountDownLatch的原理是什么？"></a><code>CountDownLatch</code>的原理是什么？</h2><p><code>CountDownLatch</code>也是共享锁的一种实现，它默认构造AQS的state值为count。当线程使用<code>countDown</code>()方法时，其实使用的是<code>tryReleaseShared</code>()方法以及CAS操作来减少state的值，直到state值为0为止。当调用<code>await</code>()方法时，如果state的值不为0，那就证明还有线程在执行任务，await方法就会一直阻塞，也就是说<code>await()</code>方法后的语句不会被执行。直到count个线程调用了<code>countDown()</code>方法时state的值减为0，或者调用<code>await()</code>方法的线程被中断，该线程才会从阻塞中唤醒，<code>await()</code> 方法之后的语句得到执行。</p><h2 id="用过-CountDownLatch-么？什么场景下用的？"><a href="#用过-CountDownLatch-么？什么场景下用的？" class="headerlink" title="用过 CountDownLatch 么？什么场景下用的？"></a>用过 CountDownLatch 么？什么场景下用的？</h2><p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p><p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p><p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AQS是什么？&quot;&gt;&lt;a href=&quot;#AQS是什么？&quot; class=&quot;headerlink&quot; title=&quot;AQS是什么？&quot;&gt;&lt;/a&gt;AQS是什么？&lt;/h2&gt;&lt;p&gt;AQS翻译过来就是抽象队列同步器，它就是一个抽象类，主要用来构建锁和同步锁。&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hhh</title>
    <link href="http://example.com/2024/08/29/hhh/"/>
    <id>http://example.com/2024/08/29/hhh/</id>
    <published>2024-08-29T10:54:15.000Z</published>
    <updated>2024-08-29T11:21:44.637Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/image-20240829185513082.png" alt="image-20240829185513082"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/image-20240829185513082.png&quot; alt=&quot;image-20240829185513082&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/08/29/hello-world/"/>
    <id>http://example.com/2024/08/29/hello-world/</id>
    <published>2024-08-29T10:22:30.835Z</published>
    <updated>2024-08-29T10:22:30.835Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
